{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"usrv : the lightest python web framework Package ( usrv ) is a pure python micro server implementation. It allows python function bindings for all HTTP methods. HTTP body can be encrypted on demand using secp256k1 keypairs. Install Developpment version $ python -m pip install git+https://github.com/Moustikitos/micro-server#egg=usrv last version (0.4.1) $ python -m pip install usrv usrv.route Bind python code to any HTTP requests easily using decorator syntax. route module can be used in standalone mode outside of usrv package. usrv.app Run a low footprint python server or PEP#3333 WSGI server . import waitress # wsgi server for windows from usrv import app, route @route.bind(\"/index\") def index(**kw): return 200, \"Index page\", kw waitress.serve(app.uApp(), threads=2) Fast and simple Let\u2019s create a server with /test endpoint in a python module named test.py : from usrv import route, app @route.bind(\"/test\") def do_test(a, b): # write some code and return something return 200, a, b def launchApp(): route.run(host=\"127.0.0.1\", port=5000, loglevel=20) Bound functions have to return a tuple with a valid HTTP status code as first item . Server can be run from python interpreter: >>> import test >>> test.launchApp() INFO:usrv.srv:listening on 127.0.0.1:5000 CTRL+C to stop... Now going to http://127.0.0.1:5000/test with any browser gives: [null, null] Extracting values from url query [null, null] above are the returned values a and b from do_test function. Values can be extracted from query string. Let\u2019s type http://127.0.0.1:5000/test?b=12&a=Paris in the address bar: [\"Paris\", \"12\"] Returned value from query are str only. Unexpected values are ignored but there is a convenient way to catch them . Extracting values from url path Values can also be extracted from url path with or without a typing precision. @route.bind(\"/<int:b>/<a>\") def do_test(a, b): # write some code and return something return 200, a, b This binding creates multiple endpoint possibilities. Let\u2019s try http://127.0.0.1:5000/5/test : [\"test\", 5] Values from url can be overrided by thoses from query\u2026 http://127.0.0.1:5000/5/test?a=2&b=6 : [\"2\", \"6\"] It can only be overrided with str type values. Catching unexpected values Using varargs or/and keywordargs is a convenient way to catch unexpected values from url query and HTTP context. HTTP Context is defined an headers and data (HTTP requests with body). When HTTP context is catched by *args , unexpected values from query string are appended next. Url used for this chapter http://127.0.0.1:5000/test?b=12&a=Paris&unexpected=there . Variable args ( *args ) @route.bind(\"/test\") def do_test(a, b, *args): # write some code and return something # args is a tuple return 200, a, b, args With *args method, HTTP headers and data will be postionned at the end of json response [ \"Paris\", \"12\", \"there\", \"GET\", { \"host\": \"127.0.0.1:5000\", \"connection\": \"keep-alive\", \"sec-ch-ua\": \"\\\"Brave\\\";v=\\\"131\\\", \\\"Chromium\\\";v=\\\"131\\\", \\\"Not_A Brand\\\";v=\\\"24\\\"\", \"sec-ch-ua-mobile\": \"?0\", \"sec-ch-ua-platform\": \"\\\"Windows\\\"\", \"upgrade-insecure-requests\": \"1\", \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36\", \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8\", \"sec-gpc\": \"1\", \"accept-language\": \"fr-FR,fr\", \"sec-fetch-site\": \"none\", \"sec-fetch-mode\": \"navigate\", \"sec-fetch-user\": \"?1\", \"sec-fetch-dest\": \"document\", \"accept-encoding\": \"gzip, deflate, br, zstd\" }, null ] Keyword args ( **kwargs ) @route.bind(\"/test\") def do_test(a, b, **kwargs): # write some code and return something # kwargs is a dict return 200, a, b, kwargs using **kwargs is the recommended way to retrieve unexpected values by names. Unexpected mapping is positionned at the end of json response. [ \"Paris\", \"12\", { \"unexpected\": \"there\", \"method\": \"GET\", \"headers\": { \"host\": \"127.0.0.1:5000\", \"connection\": \"keep-alive\", \"sec-ch-ua\": \"\\\"Brave\\\";v=\\\"131\\\", \\\"Chromium\\\";v=\\\"131\\\", \\\"Not_A Brand\\\";v=\\\"24\\\"\", \"sec-ch-ua-mobile\": \"?0\", \"sec-ch-ua-platform\": \"\\\"Windows\\\"\", \"upgrade-insecure-requests\": \"1\", \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36\", \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8\", \"sec-gpc\": \"1\", \"accept-language\": \"fr-FR,fr\", \"sec-fetch-site\": \"none\", \"sec-fetch-mode\": \"navigate\", \"sec-fetch-user\": \"?1\", \"sec-fetch-dest\": \"document\", \"accept-encoding\": \"gzip, deflate, br, zstd\" }, \"data\": null, } ] Command line WSGI server can be launched from command line. $ python wsgi_srv.py -h Usage: wsgi_srv.py [options] BINDINGS... Options: --version show program's version number and exit -h, --help show this help message and exit -t THREADS, --threads=THREADS set thread number [default: 2] -l LOGLEVEL, --log-level=LOGLEVEL set log level from 1 to 100 [default: 20] -i HOST, --ip=HOST ip to run from [default: 127.0.0.1] -p PORT, --port=PORT port to use [default: 5000] BINDINGS is a space-separated-list of python module names (ie no *.py extention) containing boud python functions. Modules containing bound functions have to be in one of sys.path folder. Specific folder can be added using wsgi_srv.path file. Changes 0.4.1 major changes and improvement, no backward compatibility with 0.3.0 0.4.2 (dev) added body encryption/decryption based on secp256k1 and AES added multipart/form-data body to req module added endpoint builder Support this project","title":"Home"},{"location":"#usrv-the-lightest-python-web-framework","text":"Package ( usrv ) is a pure python micro server implementation. It allows python function bindings for all HTTP methods. HTTP body can be encrypted on demand using secp256k1 keypairs.","title":"usrv: the lightest python web framework"},{"location":"#install","text":"","title":"Install"},{"location":"#developpment-version","text":"$ python -m pip install git+https://github.com/Moustikitos/micro-server#egg=usrv","title":"Developpment version"},{"location":"#last-version-041","text":"$ python -m pip install usrv","title":"last version (0.4.1)"},{"location":"#usrvroute","text":"Bind python code to any HTTP requests easily using decorator syntax. route module can be used in standalone mode outside of usrv package.","title":"usrv.route"},{"location":"#usrvapp","text":"Run a low footprint python server or PEP#3333 WSGI server . import waitress # wsgi server for windows from usrv import app, route @route.bind(\"/index\") def index(**kw): return 200, \"Index page\", kw waitress.serve(app.uApp(), threads=2)","title":"usrv.app"},{"location":"#fast-and-simple","text":"Let\u2019s create a server with /test endpoint in a python module named test.py : from usrv import route, app @route.bind(\"/test\") def do_test(a, b): # write some code and return something return 200, a, b def launchApp(): route.run(host=\"127.0.0.1\", port=5000, loglevel=20) Bound functions have to return a tuple with a valid HTTP status code as first item . Server can be run from python interpreter: >>> import test >>> test.launchApp() INFO:usrv.srv:listening on 127.0.0.1:5000 CTRL+C to stop... Now going to http://127.0.0.1:5000/test with any browser gives: [null, null]","title":"Fast and simple"},{"location":"#extracting-values-from-url-query","text":"[null, null] above are the returned values a and b from do_test function. Values can be extracted from query string. Let\u2019s type http://127.0.0.1:5000/test?b=12&a=Paris in the address bar: [\"Paris\", \"12\"] Returned value from query are str only. Unexpected values are ignored but there is a convenient way to catch them .","title":"Extracting values from url query"},{"location":"#extracting-values-from-url-path","text":"Values can also be extracted from url path with or without a typing precision. @route.bind(\"/<int:b>/<a>\") def do_test(a, b): # write some code and return something return 200, a, b This binding creates multiple endpoint possibilities. Let\u2019s try http://127.0.0.1:5000/5/test : [\"test\", 5] Values from url can be overrided by thoses from query\u2026 http://127.0.0.1:5000/5/test?a=2&b=6 : [\"2\", \"6\"] It can only be overrided with str type values.","title":"Extracting values from url path"},{"location":"#catching-unexpected-values","text":"Using varargs or/and keywordargs is a convenient way to catch unexpected values from url query and HTTP context. HTTP Context is defined an headers and data (HTTP requests with body). When HTTP context is catched by *args , unexpected values from query string are appended next. Url used for this chapter http://127.0.0.1:5000/test?b=12&a=Paris&unexpected=there .","title":"Catching unexpected values"},{"location":"#variable-args-args","text":"@route.bind(\"/test\") def do_test(a, b, *args): # write some code and return something # args is a tuple return 200, a, b, args With *args method, HTTP headers and data will be postionned at the end of json response [ \"Paris\", \"12\", \"there\", \"GET\", { \"host\": \"127.0.0.1:5000\", \"connection\": \"keep-alive\", \"sec-ch-ua\": \"\\\"Brave\\\";v=\\\"131\\\", \\\"Chromium\\\";v=\\\"131\\\", \\\"Not_A Brand\\\";v=\\\"24\\\"\", \"sec-ch-ua-mobile\": \"?0\", \"sec-ch-ua-platform\": \"\\\"Windows\\\"\", \"upgrade-insecure-requests\": \"1\", \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36\", \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8\", \"sec-gpc\": \"1\", \"accept-language\": \"fr-FR,fr\", \"sec-fetch-site\": \"none\", \"sec-fetch-mode\": \"navigate\", \"sec-fetch-user\": \"?1\", \"sec-fetch-dest\": \"document\", \"accept-encoding\": \"gzip, deflate, br, zstd\" }, null ]","title":"Variable args (*args)"},{"location":"#keyword-args-kwargs","text":"@route.bind(\"/test\") def do_test(a, b, **kwargs): # write some code and return something # kwargs is a dict return 200, a, b, kwargs using **kwargs is the recommended way to retrieve unexpected values by names. Unexpected mapping is positionned at the end of json response. [ \"Paris\", \"12\", { \"unexpected\": \"there\", \"method\": \"GET\", \"headers\": { \"host\": \"127.0.0.1:5000\", \"connection\": \"keep-alive\", \"sec-ch-ua\": \"\\\"Brave\\\";v=\\\"131\\\", \\\"Chromium\\\";v=\\\"131\\\", \\\"Not_A Brand\\\";v=\\\"24\\\"\", \"sec-ch-ua-mobile\": \"?0\", \"sec-ch-ua-platform\": \"\\\"Windows\\\"\", \"upgrade-insecure-requests\": \"1\", \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36\", \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8\", \"sec-gpc\": \"1\", \"accept-language\": \"fr-FR,fr\", \"sec-fetch-site\": \"none\", \"sec-fetch-mode\": \"navigate\", \"sec-fetch-user\": \"?1\", \"sec-fetch-dest\": \"document\", \"accept-encoding\": \"gzip, deflate, br, zstd\" }, \"data\": null, } ]","title":"Keyword args (**kwargs)"},{"location":"#command-line","text":"WSGI server can be launched from command line. $ python wsgi_srv.py -h Usage: wsgi_srv.py [options] BINDINGS... Options: --version show program's version number and exit -h, --help show this help message and exit -t THREADS, --threads=THREADS set thread number [default: 2] -l LOGLEVEL, --log-level=LOGLEVEL set log level from 1 to 100 [default: 20] -i HOST, --ip=HOST ip to run from [default: 127.0.0.1] -p PORT, --port=PORT port to use [default: 5000] BINDINGS is a space-separated-list of python module names (ie no *.py extention) containing boud python functions. Modules containing bound functions have to be in one of sys.path folder. Specific folder can be added using wsgi_srv.path file.","title":"Command line"},{"location":"#changes","text":"","title":"Changes"},{"location":"#041","text":"major changes and improvement, no backward compatibility with 0.3.0","title":"0.4.1"},{"location":"#042-dev","text":"added body encryption/decryption based on secp256k1 and AES added multipart/form-data body to req module added endpoint builder","title":"0.4.2 (dev)"},{"location":"#support-this-project","text":"","title":"Support this project"},{"location":"bindings/","text":"route This module contains all the utilities to launch a micro server from python lib. It is not recommended to use it in production mode. $ python route.py -h Usage: route.py [options] BINDINGS... Options: --version show program's version number and exit -h, --help show this help message and exit -t THREADS, --threads=THREADS set thread number [default: 2] -l LOGLEVEL, --log-level=LOGLEVEL set log level from 1 to 100 [default: 20] -i HOST, --ip=HOST ip to run from [default: 127.0.0.1] -p PORT, --port=PORT port to use [default: 5000] BINDINGS is a list of python modules containing python bound functions. Endpoint Objects class Endpoint() Placeholder for storing endpoint mappings. EndpointAlreadyDefined Objects class EndpointAlreadyDefined(Exception) Exception raised when an endpoint is already defined. UrlMatchError Objects class UrlMatchError(Exception) Exception raised for errors in URL pattern matching. uHTTPRequestHandler Objects class uHTTPRequestHandler(BaseHTTPRequestHandler) Custom HTTP request handler that handles HTTP methods dynamically. Methods : format_response - Formats the response as JSON. do_ - Processes HTTP requests based on registered endpoints. uHTTPRequestHandler.__getattr__ def __getattr__(attr: str) -> Callable Dynamically handles HTTP methods like \u2018do_GET\u2019, \u2018do_POST\u2019, etc. Arguments : attr str - The attribute name. Returns : Callable - The dynamic handler function. uHTTPRequestHandler.format_response @staticmethod def format_response(resp: typing.Any) -> typing.Tuple[str, str] Formats a response as JSON. Arguments : resp Any - The response data. Returns : Tuple[str, str]: The JSON response and its content type. uHTTPRequestHandler.do_ def do_(method: str = \"GET\") -> int Processes an HTTP request and calls the appropriate endpoint. Arguments : method str - The HTTP method (e.g., \u201cGET\u201d, \u201cPOST\u201d). Defaults to \u201cGET\u201d. Returns : int - Status code of the response. bind def bind(path: str, methods: list = [\"GET\"], target: BaseHTTPRequestHandler = uHTTPRequestHandler) -> Callable Binds a function to a specific URL path and HTTP methods. Arguments : path str - The URL path to bind. methods list - List of HTTP methods (e.g., [\u201cGET\u201d, \u201cPOST\u201d]). target BaseHTTPRequestHandler - The request handler class. Returns : Callable - A decorator that binds the function. callback def callback(url: str, headers: dict, data: str, function: Callable, method: str, markups: OrderedDict, regexp: re.Pattern, arg_spec: inspect.FullArgSpec) -> typing.Any Handles the execution of the bound function with appropriate arguments. the last 4 parameters are defined by the bind function and stored in the lambda callback. Arguments : url str - The full URL of the request. headers dict - The HTTP headers from the request. data str - The body of the request. function Callable - The function to execute. method str - The HTTP command used. markups OrderedDict - Mappings of path variables to their types. regexp re.Pattern - Compiled regex for path matching. arg_spec FixArgSpec - Argument specification of the function. Returns : Any - The result of the function execution. run def run(host: str = \"127.0.0.1\", port: int = 5000, loglevel: int = 20) -> None Starts the HTTP server. Arguments : host str - The IP address to bind to. Defaults to \u201c127.0.0.1\u201d. port int - The port to bind to. Defaults to 5000. loglevel int - Logging level. Defaults to 20.","title":"Bindings"},{"location":"bindings/#route","text":"This module contains all the utilities to launch a micro server from python lib. It is not recommended to use it in production mode. $ python route.py -h Usage: route.py [options] BINDINGS... Options: --version show program's version number and exit -h, --help show this help message and exit -t THREADS, --threads=THREADS set thread number [default: 2] -l LOGLEVEL, --log-level=LOGLEVEL set log level from 1 to 100 [default: 20] -i HOST, --ip=HOST ip to run from [default: 127.0.0.1] -p PORT, --port=PORT port to use [default: 5000] BINDINGS is a list of python modules containing python bound functions.","title":"route"},{"location":"bindings/#endpoint-objects","text":"class Endpoint() Placeholder for storing endpoint mappings.","title":"Endpoint Objects"},{"location":"bindings/#endpointalreadydefined-objects","text":"class EndpointAlreadyDefined(Exception) Exception raised when an endpoint is already defined.","title":"EndpointAlreadyDefined Objects"},{"location":"bindings/#urlmatcherror-objects","text":"class UrlMatchError(Exception) Exception raised for errors in URL pattern matching.","title":"UrlMatchError Objects"},{"location":"bindings/#uhttprequesthandler-objects","text":"class uHTTPRequestHandler(BaseHTTPRequestHandler) Custom HTTP request handler that handles HTTP methods dynamically. Methods : format_response - Formats the response as JSON. do_ - Processes HTTP requests based on registered endpoints.","title":"uHTTPRequestHandler Objects"},{"location":"bindings/#uhttprequesthandler__getattr__","text":"def __getattr__(attr: str) -> Callable Dynamically handles HTTP methods like \u2018do_GET\u2019, \u2018do_POST\u2019, etc. Arguments : attr str - The attribute name. Returns : Callable - The dynamic handler function.","title":"uHTTPRequestHandler.__getattr__"},{"location":"bindings/#uhttprequesthandlerformat_response","text":"@staticmethod def format_response(resp: typing.Any) -> typing.Tuple[str, str] Formats a response as JSON. Arguments : resp Any - The response data. Returns : Tuple[str, str]: The JSON response and its content type.","title":"uHTTPRequestHandler.format_response"},{"location":"bindings/#uhttprequesthandlerdo_","text":"def do_(method: str = \"GET\") -> int Processes an HTTP request and calls the appropriate endpoint. Arguments : method str - The HTTP method (e.g., \u201cGET\u201d, \u201cPOST\u201d). Defaults to \u201cGET\u201d. Returns : int - Status code of the response.","title":"uHTTPRequestHandler.do_"},{"location":"bindings/#bind","text":"def bind(path: str, methods: list = [\"GET\"], target: BaseHTTPRequestHandler = uHTTPRequestHandler) -> Callable Binds a function to a specific URL path and HTTP methods. Arguments : path str - The URL path to bind. methods list - List of HTTP methods (e.g., [\u201cGET\u201d, \u201cPOST\u201d]). target BaseHTTPRequestHandler - The request handler class. Returns : Callable - A decorator that binds the function.","title":"bind"},{"location":"bindings/#callback","text":"def callback(url: str, headers: dict, data: str, function: Callable, method: str, markups: OrderedDict, regexp: re.Pattern, arg_spec: inspect.FullArgSpec) -> typing.Any Handles the execution of the bound function with appropriate arguments. the last 4 parameters are defined by the bind function and stored in the lambda callback. Arguments : url str - The full URL of the request. headers dict - The HTTP headers from the request. data str - The body of the request. function Callable - The function to execute. method str - The HTTP command used. markups OrderedDict - Mappings of path variables to their types. regexp re.Pattern - Compiled regex for path matching. arg_spec FixArgSpec - Argument specification of the function. Returns : Any - The result of the function execution.","title":"callback"},{"location":"bindings/#run","text":"def run(host: str = \"127.0.0.1\", port: int = 5000, loglevel: int = 20) -> None Starts the HTTP server. Arguments : host str - The IP address to bind to. Defaults to \u201c127.0.0.1\u201d. port int - The port to bind to. Defaults to 5000. loglevel int - Logging level. Defaults to 20.","title":"run"},{"location":"encryption/","text":"secp256k1 EncryptionError Objects class EncryptionError(Exception) Custom exception for encryption errors. bip39_hash def bip39_hash(secret: str, passphrase: str = \"SALT\") -> bytes Returns bip39 hash bytes string. This function does not check mnemonic integrity. Arguments : secret str - a mnemonic string. passphrase str - salt string. Returns : bytes - 64 length bytes string. y_from_x def y_from_x(x: int) -> int Computes y from x according to secp256k1 equation. decode def decode(puk: str) -> tuple Decompresses a compressed secp256k1 point. Arguments : pubkey str - Compressed and encoded point. Returns : tuple - Point on secp256k1 the curve. b64encode def b64encode(point: tuple) -> str Encodes an elliptic curve point or ECDSA signaturesas a base64 string. Arguments : point tuple - The elliptic curve point as a tuple (x, y), where x and y are integers. Returns : str - The base64-encoded string representing the point. b64decode def b64decode(raw: str) -> tuple Decodes a base64-encoded string into an elliptic curve point or ECDSA signature. Arguments : raw str - The base64-encoded string. Returns : tuple - The elliptic curve point as a tuple (x, y). mod_inverse def mod_inverse(k: int, p: int) -> int Computes the modular inverse using the extended Euclidean algorithm. Arguments : k int - The integer to invert. p int - The modulus. Returns : int - The modular inverse of k modulo p. Raises : ZeroDivisionError - If k is zero. point_add def point_add(C: tuple, D: tuple) -> tuple Adds two points on the elliptic curve. Arguments : C tuple - The first point as a tuple (x, y). D tuple - The second point as a tuple (x, y). Returns : tuple - The resulting point after addition. point_double def point_double(C: tuple) -> tuple Doubles a point on the elliptic curve. Arguments : C tuple - The point to double as a tuple (x, y). Returns : tuple - The resulting point after doubling. point_multiply def point_multiply(k: int, C: tuple) -> tuple Multiplies a point P by a scalar k on the elliptic curve. Arguments : k int - The scalar multiplier. C tuple - The point to multiply as a tuple (x, y). Returns : tuple - The resulting point after multiplication. generate_keypair def generate_keypair(secret: str = None) Generates a private and public key pair for SECP256k1. Returns : tuple - A tuple containing the private key (int) and the base64-encoded public key. sign def sign(message: str, private_key: int) -> str Signs a message using a private key. Arguments : message str - The message to sign. private_key int - The private key used for signing. Returns : str - The base64-encoded signature. verify def verify(message: str, signature: str, public_key: str) -> bool Verifies an ECDSA signature using a public key. Arguments : message str - The signed message. signature str - The base64-encoded signature. public_key str - The base64-encoded public key. Returns : bool - True if the signature is valid, False otherwise. aes_encrypt def aes_encrypt(data: str, secret: str) -> str Encrypts data using AES with a secret. Arguments : data str - The plaintext data to encrypt. secret str - The secret key for encryption. Returns : str - The encrypted data as a hexadecimal string. aes_decrypt def aes_decrypt(data: str, secret: str) -> str Decrypts AES-encrypted data using a secret. Arguments : data str - The encrypted data as a hexadecimal string. secret str - The secret key for decryption. Returns : str|bool - The decrypted plaintext data, or False if decryption fails. encrypt def encrypt(public_key: str, message: str) -> typing.Tuple[str, str] Encrypts a message using a public key. Arguments : public_key str - The base64-encoded public key. message str - The plaintext message to encrypt. Returns : tuple - A tuple containing the base64-encoded R value and the encrypted message as a hexadecimal string. decrypt def decrypt(private_key: int, R: str, ciphered: str) -> str Decrypts a message using a private key. Arguments : private_key int - The base64-encoded private key. R str - The base64-encoded ephemeral public key. ciphered str - The ciphered message to decrypt. Returns : str - Message as plaintext.","title":"Encryption"},{"location":"encryption/#secp256k1","text":"","title":"secp256k1"},{"location":"encryption/#encryptionerror-objects","text":"class EncryptionError(Exception) Custom exception for encryption errors.","title":"EncryptionError Objects"},{"location":"encryption/#bip39_hash","text":"def bip39_hash(secret: str, passphrase: str = \"SALT\") -> bytes Returns bip39 hash bytes string. This function does not check mnemonic integrity. Arguments : secret str - a mnemonic string. passphrase str - salt string. Returns : bytes - 64 length bytes string.","title":"bip39_hash"},{"location":"encryption/#y_from_x","text":"def y_from_x(x: int) -> int Computes y from x according to secp256k1 equation.","title":"y_from_x"},{"location":"encryption/#decode","text":"def decode(puk: str) -> tuple Decompresses a compressed secp256k1 point. Arguments : pubkey str - Compressed and encoded point. Returns : tuple - Point on secp256k1 the curve.","title":"decode"},{"location":"encryption/#b64encode","text":"def b64encode(point: tuple) -> str Encodes an elliptic curve point or ECDSA signaturesas a base64 string. Arguments : point tuple - The elliptic curve point as a tuple (x, y), where x and y are integers. Returns : str - The base64-encoded string representing the point.","title":"b64encode"},{"location":"encryption/#b64decode","text":"def b64decode(raw: str) -> tuple Decodes a base64-encoded string into an elliptic curve point or ECDSA signature. Arguments : raw str - The base64-encoded string. Returns : tuple - The elliptic curve point as a tuple (x, y).","title":"b64decode"},{"location":"encryption/#mod_inverse","text":"def mod_inverse(k: int, p: int) -> int Computes the modular inverse using the extended Euclidean algorithm. Arguments : k int - The integer to invert. p int - The modulus. Returns : int - The modular inverse of k modulo p. Raises : ZeroDivisionError - If k is zero.","title":"mod_inverse"},{"location":"encryption/#point_add","text":"def point_add(C: tuple, D: tuple) -> tuple Adds two points on the elliptic curve. Arguments : C tuple - The first point as a tuple (x, y). D tuple - The second point as a tuple (x, y). Returns : tuple - The resulting point after addition.","title":"point_add"},{"location":"encryption/#point_double","text":"def point_double(C: tuple) -> tuple Doubles a point on the elliptic curve. Arguments : C tuple - The point to double as a tuple (x, y). Returns : tuple - The resulting point after doubling.","title":"point_double"},{"location":"encryption/#point_multiply","text":"def point_multiply(k: int, C: tuple) -> tuple Multiplies a point P by a scalar k on the elliptic curve. Arguments : k int - The scalar multiplier. C tuple - The point to multiply as a tuple (x, y). Returns : tuple - The resulting point after multiplication.","title":"point_multiply"},{"location":"encryption/#generate_keypair","text":"def generate_keypair(secret: str = None) Generates a private and public key pair for SECP256k1. Returns : tuple - A tuple containing the private key (int) and the base64-encoded public key.","title":"generate_keypair"},{"location":"encryption/#sign","text":"def sign(message: str, private_key: int) -> str Signs a message using a private key. Arguments : message str - The message to sign. private_key int - The private key used for signing. Returns : str - The base64-encoded signature.","title":"sign"},{"location":"encryption/#verify","text":"def verify(message: str, signature: str, public_key: str) -> bool Verifies an ECDSA signature using a public key. Arguments : message str - The signed message. signature str - The base64-encoded signature. public_key str - The base64-encoded public key. Returns : bool - True if the signature is valid, False otherwise.","title":"verify"},{"location":"encryption/#aes_encrypt","text":"def aes_encrypt(data: str, secret: str) -> str Encrypts data using AES with a secret. Arguments : data str - The plaintext data to encrypt. secret str - The secret key for encryption. Returns : str - The encrypted data as a hexadecimal string.","title":"aes_encrypt"},{"location":"encryption/#aes_decrypt","text":"def aes_decrypt(data: str, secret: str) -> str Decrypts AES-encrypted data using a secret. Arguments : data str - The encrypted data as a hexadecimal string. secret str - The secret key for decryption. Returns : str|bool - The decrypted plaintext data, or False if decryption fails.","title":"aes_decrypt"},{"location":"encryption/#encrypt","text":"def encrypt(public_key: str, message: str) -> typing.Tuple[str, str] Encrypts a message using a public key. Arguments : public_key str - The base64-encoded public key. message str - The plaintext message to encrypt. Returns : tuple - A tuple containing the base64-encoded R value and the encrypted message as a hexadecimal string.","title":"encrypt"},{"location":"encryption/#decrypt","text":"def decrypt(private_key: int, R: str, ciphered: str) -> str Decrypts a message using a private key. Arguments : private_key int - The base64-encoded private key. R str - The base64-encoded ephemeral public key. ciphered str - The ciphered message to decrypt. Returns : str - Message as plaintext.","title":"decrypt"},{"location":"request/","text":"req This module is designed to handle common HTTP operations in a clean and reusable manner, with dynamic endpoint resolution and robust response management. Let\u2019s run a micro server: from usrv import route # allow req.Endpoint.connect @route.bind(\"/\", methods=[\"HEAD\"]) def base(): return 200, @route.bind(\"/index\") def index(*args): return (200, ) + args @route.bind(\"/api/endpoint\", methods=[\"GET\", \"POST\"]) def endpoit(a, b, **kwargs): method = kwargs[\"method\"] if method == \"POST\": return 202, elif method == \"GET\": return 200, a, b, kwargs else: return 404, route.run(host='127.0.0.1', port=5000) execute simple requests: >>> from usrv import req >>> req.Endpoint.connect(\"http://127.0.0.1:5000\") 200 >>> req.GET.index() [{'accept-encoding': 'identity', 'host': '127.0.0.1:5000', 'user-agent': 'Python/usrv', 'content-type': 'application/json', 'connection': 'close'}, None] >>> req.GET.api.endpoint() [None, None, {'headers': {'accept-encoding': 'identity', 'host': '127.0.0.1:5000', 'user-agent': 'Python/usrv', 'content-type': 'application/json', 'connection': 'close'}, 'data': None}] >>> req.POST.api.endpoint() [] build_request def build_request(method: str = \"GET\", path: str = \"/\", **kwargs) -> Request Builds an HTTP request object. Arguments : method str - HTTP method (e.g., \u2018GET\u2019, \u2018POST\u2019). Defaults to \u2018GET\u2019. path str - URL path for the request. Defaults to \u2018/\u2019. **kwargs - Additional keyword arguments for query parameters, headers, and data. Returns : Request - Configured HTTP request object. manage_response def manage_response(resp: HTTPResponse) -> typing.Union[dict, str] Parses the HTTP response. Arguments : resp HTTPResponse - HTTP response object. Returns : typing.Union[dict, str]: Decoded response content. RequestCache Objects class RequestCache() Cache manager for HTTP Request objects. RequestCache.__init__ def __init__(max_size: int = 100, ttl: int = 300) Initialize the cache. Arguments : max_size int - Maximum number of entries in the cache. ttl int - Time-to-live for cache entries in seconds. RequestCache.generate_key @staticmethod def generate_key(method: str, path: str, **kwargs) -> str Generate a unique cache key for a request. RequestCache.get def get(key: str) -> typing.Union[None, typing.Tuple[int, Request]] Retrieve an entry from the cache. RequestCache.set def set(key: str, request: Request) -> None Add an entry to the cache. Endpoint Objects class Endpoint() Represents an HTTP endpoint with dynamic attribute handling. Attributes : startswith_ re.Pattern - Pattern to match internal attributes. timeout int - Default timeout for requests. opener OpenerDirector - Opener to handle HTTP requests. peer str - Base URL for the endpoint. Endpoint.__init__ def __init__(master: typing.Any = None, name: str = \"\", method: Callable = manage_response) -> None Initializes an Endpoint instance. Arguments : master typing.Any - Parent endpoint. name str - Name of the current endpoint. method Callable - Request-building method. Endpoint.__getattr__ def __getattr__(attr: str) -> typing.Any Dynamically resolves sub-endpoints. Arguments : attr str - Attribute name. Returns : Endpoint - New sub-endpoint instance. Endpoint.__call__ def __call__(**kwargs) -> typing.Any Executes the endpoint\u2019s method with provided arguments. Arguments : **kwargs - Parameters for the HTTP request. Returns : typing.Any - value returned by method attribute. Endpoint.connect @staticmethod def connect(peer: str) -> typing.Union[int, bool] Tests connection to a peer endpoint and store it if success. Arguments : peer str - Peer URL to test. Returns : typing.Union[int, bool]: HTTP status code or False on failure. build_endpoint def build_endpoint(http_req: str = \"GET\", encoder: Callable = json.dumps, timeout: int = Endpoint.timeout) -> Endpoint Creates a root endpoint. Arguments : http_req str - Name of HTTP method (i.e. HEAD, GET, POST etc\u2026). encoder Callable - Data encoder function to use. timeout int - Request timeout in seconds. Returns : Endpoint - Root endpoint.","title":"Request"},{"location":"request/#req","text":"This module is designed to handle common HTTP operations in a clean and reusable manner, with dynamic endpoint resolution and robust response management. Let\u2019s run a micro server: from usrv import route # allow req.Endpoint.connect @route.bind(\"/\", methods=[\"HEAD\"]) def base(): return 200, @route.bind(\"/index\") def index(*args): return (200, ) + args @route.bind(\"/api/endpoint\", methods=[\"GET\", \"POST\"]) def endpoit(a, b, **kwargs): method = kwargs[\"method\"] if method == \"POST\": return 202, elif method == \"GET\": return 200, a, b, kwargs else: return 404, route.run(host='127.0.0.1', port=5000) execute simple requests: >>> from usrv import req >>> req.Endpoint.connect(\"http://127.0.0.1:5000\") 200 >>> req.GET.index() [{'accept-encoding': 'identity', 'host': '127.0.0.1:5000', 'user-agent': 'Python/usrv', 'content-type': 'application/json', 'connection': 'close'}, None] >>> req.GET.api.endpoint() [None, None, {'headers': {'accept-encoding': 'identity', 'host': '127.0.0.1:5000', 'user-agent': 'Python/usrv', 'content-type': 'application/json', 'connection': 'close'}, 'data': None}] >>> req.POST.api.endpoint() []","title":"req"},{"location":"request/#build_request","text":"def build_request(method: str = \"GET\", path: str = \"/\", **kwargs) -> Request Builds an HTTP request object. Arguments : method str - HTTP method (e.g., \u2018GET\u2019, \u2018POST\u2019). Defaults to \u2018GET\u2019. path str - URL path for the request. Defaults to \u2018/\u2019. **kwargs - Additional keyword arguments for query parameters, headers, and data. Returns : Request - Configured HTTP request object.","title":"build_request"},{"location":"request/#manage_response","text":"def manage_response(resp: HTTPResponse) -> typing.Union[dict, str] Parses the HTTP response. Arguments : resp HTTPResponse - HTTP response object. Returns : typing.Union[dict, str]: Decoded response content.","title":"manage_response"},{"location":"request/#requestcache-objects","text":"class RequestCache() Cache manager for HTTP Request objects.","title":"RequestCache Objects"},{"location":"request/#requestcache__init__","text":"def __init__(max_size: int = 100, ttl: int = 300) Initialize the cache. Arguments : max_size int - Maximum number of entries in the cache. ttl int - Time-to-live for cache entries in seconds.","title":"RequestCache.__init__"},{"location":"request/#requestcachegenerate_key","text":"@staticmethod def generate_key(method: str, path: str, **kwargs) -> str Generate a unique cache key for a request.","title":"RequestCache.generate_key"},{"location":"request/#requestcacheget","text":"def get(key: str) -> typing.Union[None, typing.Tuple[int, Request]] Retrieve an entry from the cache.","title":"RequestCache.get"},{"location":"request/#requestcacheset","text":"def set(key: str, request: Request) -> None Add an entry to the cache.","title":"RequestCache.set"},{"location":"request/#endpoint-objects","text":"class Endpoint() Represents an HTTP endpoint with dynamic attribute handling. Attributes : startswith_ re.Pattern - Pattern to match internal attributes. timeout int - Default timeout for requests. opener OpenerDirector - Opener to handle HTTP requests. peer str - Base URL for the endpoint.","title":"Endpoint Objects"},{"location":"request/#endpoint__init__","text":"def __init__(master: typing.Any = None, name: str = \"\", method: Callable = manage_response) -> None Initializes an Endpoint instance. Arguments : master typing.Any - Parent endpoint. name str - Name of the current endpoint. method Callable - Request-building method.","title":"Endpoint.__init__"},{"location":"request/#endpoint__getattr__","text":"def __getattr__(attr: str) -> typing.Any Dynamically resolves sub-endpoints. Arguments : attr str - Attribute name. Returns : Endpoint - New sub-endpoint instance.","title":"Endpoint.__getattr__"},{"location":"request/#endpoint__call__","text":"def __call__(**kwargs) -> typing.Any Executes the endpoint\u2019s method with provided arguments. Arguments : **kwargs - Parameters for the HTTP request. Returns : typing.Any - value returned by method attribute.","title":"Endpoint.__call__"},{"location":"request/#endpointconnect","text":"@staticmethod def connect(peer: str) -> typing.Union[int, bool] Tests connection to a peer endpoint and store it if success. Arguments : peer str - Peer URL to test. Returns : typing.Union[int, bool]: HTTP status code or False on failure.","title":"Endpoint.connect"},{"location":"request/#build_endpoint","text":"def build_endpoint(http_req: str = \"GET\", encoder: Callable = json.dumps, timeout: int = Endpoint.timeout) -> Endpoint Creates a root endpoint. Arguments : http_req str - Name of HTTP method (i.e. HEAD, GET, POST etc\u2026). encoder Callable - Data encoder function to use. timeout int - Request timeout in seconds. Returns : Endpoint - Root endpoint.","title":"build_endpoint"},{"location":"serving/","text":"app This module contains all the utilities to launch a WSGI micro server (highly recommended in production mode). uApp Objects class uApp() Represents a lightweight application server that can handle HTTP requests, optionally wrap its socket with SSL, and run in a testing mode. Attributes : handler BaseHTTPRequestHandler - HTTP request handler. host str - The hostname for the server. port int - The port number for the server. uApp.__init__ def __init__(host: str = \"127.0.0.1\", port: int = 5000, loglevel: int = 20, handler: BaseHTTPRequestHandler = route.uHTTPRequestHandler) Initializes the uApp instance with a specified host, port, logging level, and request handler. Arguments : host str - Hostname for the server. Defaults to \u201c127.0.0.1\u201d. port int - Port number for the server. Defaults to 5000. loglevel int - Logging level. Defaults to 20 (INFO). handler BaseHTTPRequestHandler - Request handler. Defaults to route.uHTTPRequestHandler . uApp.__call__ def __call__(environ: dict, start_response: Callable) -> bytes Enables the application to be callable as a WSGI application. Arguments : environ dict - The WSGI environment dictionary. start_response callable - A callable to start the HTTP response. Returns : Callable - The response iterable. uApp.wrap def wrap() -> bool Wraps the HTTP server\u2019s socket with SSL if a certificate and key are available. Returns : bool - True if the socket is successfully wrapped with SSL, False otherwise. uApp.run def run(ssl: bool = False) Starts the HTTP server, optionally wrapping the socket with SSL. This method is designed for testing purposes only. Arguments : ssl bool - If True, wraps the server\u2019s socket with SSL. Defaults to False.","title":"Serving"},{"location":"serving/#app","text":"This module contains all the utilities to launch a WSGI micro server (highly recommended in production mode).","title":"app"},{"location":"serving/#uapp-objects","text":"class uApp() Represents a lightweight application server that can handle HTTP requests, optionally wrap its socket with SSL, and run in a testing mode. Attributes : handler BaseHTTPRequestHandler - HTTP request handler. host str - The hostname for the server. port int - The port number for the server.","title":"uApp Objects"},{"location":"serving/#uapp__init__","text":"def __init__(host: str = \"127.0.0.1\", port: int = 5000, loglevel: int = 20, handler: BaseHTTPRequestHandler = route.uHTTPRequestHandler) Initializes the uApp instance with a specified host, port, logging level, and request handler. Arguments : host str - Hostname for the server. Defaults to \u201c127.0.0.1\u201d. port int - Port number for the server. Defaults to 5000. loglevel int - Logging level. Defaults to 20 (INFO). handler BaseHTTPRequestHandler - Request handler. Defaults to route.uHTTPRequestHandler .","title":"uApp.__init__"},{"location":"serving/#uapp__call__","text":"def __call__(environ: dict, start_response: Callable) -> bytes Enables the application to be callable as a WSGI application. Arguments : environ dict - The WSGI environment dictionary. start_response callable - A callable to start the HTTP response. Returns : Callable - The response iterable.","title":"uApp.__call__"},{"location":"serving/#uappwrap","text":"def wrap() -> bool Wraps the HTTP server\u2019s socket with SSL if a certificate and key are available. Returns : bool - True if the socket is successfully wrapped with SSL, False otherwise.","title":"uApp.wrap"},{"location":"serving/#uapprun","text":"def run(ssl: bool = False) Starts the HTTP server, optionally wrapping the socket with SSL. This method is designed for testing purposes only. Arguments : ssl bool - If True, wraps the server\u2019s socket with SSL. Defaults to False.","title":"uApp.run"},{"location":"wsgi-server/","text":"wsgi_srv This module serves as an HTTP server using the Waitress WSGI server. It provides command-line options for configuring the server\u2019s host, port, log level, and number of threads. If no additional modules are specified as arguments, default routes are defined for testing purposes, including endpoints that demonstrate handling of positional and keyword arguments, as well as error scenarios. Command-line options: --threads: Set the number of threads to use (default: 2). --log-level: Set the logging level from 1 to 100 (default: 20). --ip: Specify the IP address for the server (default: 127.0.0.1). --port: Specify the port for the server (default: 5000). Example usage: $ python wsgi_py.py --threads 4 --log-level 30 --ip 0.0.0.0 --port 8000","title":"Wsgi server"},{"location":"wsgi-server/#wsgi_srv","text":"This module serves as an HTTP server using the Waitress WSGI server. It provides command-line options for configuring the server\u2019s host, port, log level, and number of threads. If no additional modules are specified as arguments, default routes are defined for testing purposes, including endpoints that demonstrate handling of positional and keyword arguments, as well as error scenarios.","title":"wsgi_srv"},{"location":"wsgi-server/#command-line-options","text":"--threads: Set the number of threads to use (default: 2). --log-level: Set the logging level from 1 to 100 (default: 20). --ip: Specify the IP address for the server (default: 127.0.0.1). --port: Specify the port for the server (default: 5000).","title":"Command-line options:"},{"location":"wsgi-server/#example-usage","text":"$ python wsgi_py.py --threads 4 --log-level 30 --ip 0.0.0.0 --port 8000","title":"Example usage:"}]}