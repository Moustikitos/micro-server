{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"usrv Package Name: usrv This package implements a lightweight Web Server Gateway Interface (WSGI) for deploying Python web applications. It follows the WSGI specification outlined in PEP 3333, providing a flexible interface for handling HTTP requests and responses. Modules: wsgi: Implements the core WSGI functionality, including request handling and URL reconstruction. route: Provides the web server capabilities, handling of incoming requests and endpoint management. req: Provides a light request interface and with a pythonic way to access remote resources. app: Provides the root app to be run behind WSGI for production mode. secp256k1: Provides all functions for ECIES encryption and ECDSA signature. Features: Route binding: Easily bind URL patterns to Python functions. Flexible response handling: Customize responses based on the request method and URL. Error management: Handle common HTTP errors with appropriate status codes. Encryption: server and client side HTTP body encryption on demand. Usage: To use this package, import the relevant modules and define your endpoints using the provided routing functionality. Start the server with the desired configuration for host, port, and threading options. For more details, see the documentation and examples in the respective modules.","title":"Home"},{"location":"#usrv","text":"Package Name: usrv This package implements a lightweight Web Server Gateway Interface (WSGI) for deploying Python web applications. It follows the WSGI specification outlined in PEP 3333, providing a flexible interface for handling HTTP requests and responses.","title":"usrv"},{"location":"#modules","text":"wsgi: Implements the core WSGI functionality, including request handling and URL reconstruction. route: Provides the web server capabilities, handling of incoming requests and endpoint management. req: Provides a light request interface and with a pythonic way to access remote resources. app: Provides the root app to be run behind WSGI for production mode. secp256k1: Provides all functions for ECIES encryption and ECDSA signature.","title":"Modules:"},{"location":"#features","text":"Route binding: Easily bind URL patterns to Python functions. Flexible response handling: Customize responses based on the request method and URL. Error management: Handle common HTTP errors with appropriate status codes. Encryption: server and client side HTTP body encryption on demand.","title":"Features:"},{"location":"#usage","text":"To use this package, import the relevant modules and define your endpoints using the provided routing functionality. Start the server with the desired configuration for host, port, and threading options. For more details, see the documentation and examples in the respective modules.","title":"Usage:"},{"location":"bindings/","text":"route This module contains all the utilities to launch a micro server from python lib. It is not recommended to use it in production mode. $ python route.py -h Usage: route.py [options] BINDINGS... Options: --version show program's version number and exit -h, --help show this help message and exit -t THREADS, --threads=THREADS set thread number [default: 2] -l LOGLEVEL, --log-level=LOGLEVEL set log level from 1 to 100 [default: 20] -i HOST, --ip=HOST ip to run from [default: 127.0.0.1] -p PORT, --port=PORT port to use [default: 5000] BINDINGS is a list of python modules containing python bound functions. Endpoint Objects class Endpoint() Placeholder for storing endpoint mappings. EndpointAlreadyDefined Objects class EndpointAlreadyDefined(Exception) Exception raised when an endpoint is already defined. UrlMatchError Objects class UrlMatchError(Exception) Exception raised for errors in URL pattern matching. uHTTPRequestHandler Objects class uHTTPRequestHandler(BaseHTTPRequestHandler) Custom HTTP request handler that handles HTTP methods dynamically. Methods : format_response - Formats the response as JSON. do_ - Processes HTTP requests based on registered endpoints. uHTTPRequestHandler.__getattr__ def __getattr__(attr: str) -> Callable Dynamically handles HTTP methods like \u2018do_GET\u2019, \u2018do_POST\u2019, etc. Arguments : attr str - The attribute name. Returns : Callable - The dynamic handler function. uHTTPRequestHandler.format_response @staticmethod def format_response(resp: typing.Any) -> typing.Tuple[str, str] Formats a response as JSON. Arguments : resp Any - The response data. Returns : Tuple[str, str]: The JSON response and its content type. uHTTPRequestHandler.do_ def do_(method: str = \"GET\") -> int Processes an HTTP request and calls the appropriate endpoint. Arguments : method str - The HTTP method (e.g., \u201cGET\u201d, \u201cPOST\u201d). Defaults to \u201cGET\u201d. Returns : int - Status code of the response. bind def bind(path: str, methods: list = [\"GET\"], target: BaseHTTPRequestHandler = uHTTPRequestHandler) -> Callable Binds a function to a specific URL path and HTTP methods. Arguments : path str - The URL path to bind. methods list - List of HTTP methods (e.g., [\u201cGET\u201d, \u201cPOST\u201d]). target BaseHTTPRequestHandler - The request handler class. Returns : Callable - A decorator that binds the function. callback def callback(url: str, headers: dict, data: str, function: Callable, method: str, markups: OrderedDict, regexp: re.Pattern, arg_spec: inspect.FullArgSpec) -> typing.Any Handles the execution of the bound function with appropriate arguments. the last 4 parameters are defined by the bind function and stored in the lambda callback. Arguments : url str - The full URL of the request. headers dict - The HTTP headers from the request. data str - The body of the request. function Callable - The function to execute. method str - The HTTP command used. markups OrderedDict - Mappings of path variables to their types. regexp re.Pattern - Compiled regex for path matching. arg_spec FixArgSpec - Argument specification of the function. Returns : Any - The result of the function execution. run def run(host: str = \"127.0.0.1\", port: int = 5000, loglevel: int = 20) -> None Starts the HTTP server. Arguments : host str - The IP address to bind to. Defaults to \u201c127.0.0.1\u201d. port int - The port to bind to. Defaults to 5000. loglevel int - Logging level. Defaults to 20.","title":"Bindings"},{"location":"bindings/#route","text":"This module contains all the utilities to launch a micro server from python lib. It is not recommended to use it in production mode. $ python route.py -h Usage: route.py [options] BINDINGS... Options: --version show program's version number and exit -h, --help show this help message and exit -t THREADS, --threads=THREADS set thread number [default: 2] -l LOGLEVEL, --log-level=LOGLEVEL set log level from 1 to 100 [default: 20] -i HOST, --ip=HOST ip to run from [default: 127.0.0.1] -p PORT, --port=PORT port to use [default: 5000] BINDINGS is a list of python modules containing python bound functions.","title":"route"},{"location":"bindings/#endpoint-objects","text":"class Endpoint() Placeholder for storing endpoint mappings.","title":"Endpoint Objects"},{"location":"bindings/#endpointalreadydefined-objects","text":"class EndpointAlreadyDefined(Exception) Exception raised when an endpoint is already defined.","title":"EndpointAlreadyDefined Objects"},{"location":"bindings/#urlmatcherror-objects","text":"class UrlMatchError(Exception) Exception raised for errors in URL pattern matching.","title":"UrlMatchError Objects"},{"location":"bindings/#uhttprequesthandler-objects","text":"class uHTTPRequestHandler(BaseHTTPRequestHandler) Custom HTTP request handler that handles HTTP methods dynamically. Methods : format_response - Formats the response as JSON. do_ - Processes HTTP requests based on registered endpoints.","title":"uHTTPRequestHandler Objects"},{"location":"bindings/#uhttprequesthandler__getattr__","text":"def __getattr__(attr: str) -> Callable Dynamically handles HTTP methods like \u2018do_GET\u2019, \u2018do_POST\u2019, etc. Arguments : attr str - The attribute name. Returns : Callable - The dynamic handler function.","title":"uHTTPRequestHandler.__getattr__"},{"location":"bindings/#uhttprequesthandlerformat_response","text":"@staticmethod def format_response(resp: typing.Any) -> typing.Tuple[str, str] Formats a response as JSON. Arguments : resp Any - The response data. Returns : Tuple[str, str]: The JSON response and its content type.","title":"uHTTPRequestHandler.format_response"},{"location":"bindings/#uhttprequesthandlerdo_","text":"def do_(method: str = \"GET\") -> int Processes an HTTP request and calls the appropriate endpoint. Arguments : method str - The HTTP method (e.g., \u201cGET\u201d, \u201cPOST\u201d). Defaults to \u201cGET\u201d. Returns : int - Status code of the response.","title":"uHTTPRequestHandler.do_"},{"location":"bindings/#bind","text":"def bind(path: str, methods: list = [\"GET\"], target: BaseHTTPRequestHandler = uHTTPRequestHandler) -> Callable Binds a function to a specific URL path and HTTP methods. Arguments : path str - The URL path to bind. methods list - List of HTTP methods (e.g., [\u201cGET\u201d, \u201cPOST\u201d]). target BaseHTTPRequestHandler - The request handler class. Returns : Callable - A decorator that binds the function.","title":"bind"},{"location":"bindings/#callback","text":"def callback(url: str, headers: dict, data: str, function: Callable, method: str, markups: OrderedDict, regexp: re.Pattern, arg_spec: inspect.FullArgSpec) -> typing.Any Handles the execution of the bound function with appropriate arguments. the last 4 parameters are defined by the bind function and stored in the lambda callback. Arguments : url str - The full URL of the request. headers dict - The HTTP headers from the request. data str - The body of the request. function Callable - The function to execute. method str - The HTTP command used. markups OrderedDict - Mappings of path variables to their types. regexp re.Pattern - Compiled regex for path matching. arg_spec FixArgSpec - Argument specification of the function. Returns : Any - The result of the function execution.","title":"callback"},{"location":"bindings/#run","text":"def run(host: str = \"127.0.0.1\", port: int = 5000, loglevel: int = 20) -> None Starts the HTTP server. Arguments : host str - The IP address to bind to. Defaults to \u201c127.0.0.1\u201d. port int - The port to bind to. Defaults to 5000. loglevel int - Logging level. Defaults to 20.","title":"run"},{"location":"encryption/","text":"secp256k1 EncryptionError Objects class EncryptionError(Exception) Custom exception for encryption errors. bip39_hash def bip39_hash(secret: str, passphrase: str = \"SALT\") -> bytes Returns bip39 hash bytes string. This function does not check mnemonic integrity. Arguments : secret str - a mnemonic string. passphrase str - salt string. Returns : bytes - 64 length bytes string. y_from_x def y_from_x(x: int) -> int Computes y from x according to secp256k1 equation. decode def decode(puk: str) -> tuple Decompresses a compressed secp256k1 point. Arguments : pubkey str - Compressed and encoded point. Returns : tuple - Point on secp256k1 the curve. b64encode def b64encode(point: tuple) -> str Encodes an elliptic curve point or ECDSA signaturesas a base64 string. Arguments : point tuple - The elliptic curve point as a tuple (x, y), where x and y are integers. Returns : str - The base64-encoded string representing the point. b64decode def b64decode(raw: str) -> tuple Decodes a base64-encoded string into an elliptic curve point or ECDSA signature. Arguments : raw str - The base64-encoded string. Returns : tuple - The elliptic curve point as a tuple (x, y). mod_inverse def mod_inverse(k: int, p: int) -> int Computes the modular inverse using the extended Euclidean algorithm. Arguments : k int - The integer to invert. p int - The modulus. Returns : int - The modular inverse of k modulo p. Raises : ZeroDivisionError - If k is zero. point_add def point_add(C: tuple, D: tuple) -> tuple Adds two points on the elliptic curve. Arguments : C tuple - The first point as a tuple (x, y). D tuple - The second point as a tuple (x, y). Returns : tuple - The resulting point after addition. point_double def point_double(C: tuple) -> tuple Doubles a point on the elliptic curve. Arguments : C tuple - The point to double as a tuple (x, y). Returns : tuple - The resulting point after doubling. point_multiply def point_multiply(k: int, C: tuple) -> tuple Multiplies a point P by a scalar k on the elliptic curve. Arguments : k int - The scalar multiplier. C tuple - The point to multiply as a tuple (x, y). Returns : tuple - The resulting point after multiplication. generate_keypair def generate_keypair(secret: str = None) Generates a private and public key pair for SECP256k1. Returns : tuple - A tuple containing the private key (int) and the base64-encoded public key. sign def sign(message: str, private_key: int) -> str Signs a message using a private key. Arguments : message str - The message to sign. private_key int - The private key used for signing. Returns : str - The base64-encoded signature. verify def verify(message: str, signature: str, public_key: str) -> bool Verifies an ECDSA signature using a public key. Arguments : message str - The signed message. signature str - The base64-encoded signature. public_key str - The base64-encoded public key. Returns : bool - True if the signature is valid, False otherwise. aes_encrypt def aes_encrypt(data: str, secret: str) -> str Encrypts data using AES with a secret. Arguments : data str - The plaintext data to encrypt. secret str - The secret key for encryption. Returns : str - The encrypted data as a hexadecimal string. aes_decrypt def aes_decrypt(data: str, secret: str) -> str Decrypts AES-encrypted data using a secret. Arguments : data str - The encrypted data as a hexadecimal string. secret str - The secret key for decryption. Returns : str|bool - The decrypted plaintext data, or False if decryption fails. encrypt def encrypt(public_key: str, message: str) -> typing.Tuple[str, str] Encrypts a message using a public key. Arguments : public_key str - The base64-encoded public key. message str - The plaintext message to encrypt. Returns : tuple - A tuple containing the base64-encoded R value and the encrypted message as a hexadecimal string. decrypt def decrypt(private_key: int, R: str, ciphered: str) -> str Decrypts a message using a private key. Arguments : private_key int - The base64-encoded private key. R str - The base64-encoded ephemeral public key. ciphered str - The ciphered message to decrypt. Returns : str - Message as plaintext.","title":"Encryption"},{"location":"encryption/#secp256k1","text":"","title":"secp256k1"},{"location":"encryption/#encryptionerror-objects","text":"class EncryptionError(Exception) Custom exception for encryption errors.","title":"EncryptionError Objects"},{"location":"encryption/#bip39_hash","text":"def bip39_hash(secret: str, passphrase: str = \"SALT\") -> bytes Returns bip39 hash bytes string. This function does not check mnemonic integrity. Arguments : secret str - a mnemonic string. passphrase str - salt string. Returns : bytes - 64 length bytes string.","title":"bip39_hash"},{"location":"encryption/#y_from_x","text":"def y_from_x(x: int) -> int Computes y from x according to secp256k1 equation.","title":"y_from_x"},{"location":"encryption/#decode","text":"def decode(puk: str) -> tuple Decompresses a compressed secp256k1 point. Arguments : pubkey str - Compressed and encoded point. Returns : tuple - Point on secp256k1 the curve.","title":"decode"},{"location":"encryption/#b64encode","text":"def b64encode(point: tuple) -> str Encodes an elliptic curve point or ECDSA signaturesas a base64 string. Arguments : point tuple - The elliptic curve point as a tuple (x, y), where x and y are integers. Returns : str - The base64-encoded string representing the point.","title":"b64encode"},{"location":"encryption/#b64decode","text":"def b64decode(raw: str) -> tuple Decodes a base64-encoded string into an elliptic curve point or ECDSA signature. Arguments : raw str - The base64-encoded string. Returns : tuple - The elliptic curve point as a tuple (x, y).","title":"b64decode"},{"location":"encryption/#mod_inverse","text":"def mod_inverse(k: int, p: int) -> int Computes the modular inverse using the extended Euclidean algorithm. Arguments : k int - The integer to invert. p int - The modulus. Returns : int - The modular inverse of k modulo p. Raises : ZeroDivisionError - If k is zero.","title":"mod_inverse"},{"location":"encryption/#point_add","text":"def point_add(C: tuple, D: tuple) -> tuple Adds two points on the elliptic curve. Arguments : C tuple - The first point as a tuple (x, y). D tuple - The second point as a tuple (x, y). Returns : tuple - The resulting point after addition.","title":"point_add"},{"location":"encryption/#point_double","text":"def point_double(C: tuple) -> tuple Doubles a point on the elliptic curve. Arguments : C tuple - The point to double as a tuple (x, y). Returns : tuple - The resulting point after doubling.","title":"point_double"},{"location":"encryption/#point_multiply","text":"def point_multiply(k: int, C: tuple) -> tuple Multiplies a point P by a scalar k on the elliptic curve. Arguments : k int - The scalar multiplier. C tuple - The point to multiply as a tuple (x, y). Returns : tuple - The resulting point after multiplication.","title":"point_multiply"},{"location":"encryption/#generate_keypair","text":"def generate_keypair(secret: str = None) Generates a private and public key pair for SECP256k1. Returns : tuple - A tuple containing the private key (int) and the base64-encoded public key.","title":"generate_keypair"},{"location":"encryption/#sign","text":"def sign(message: str, private_key: int) -> str Signs a message using a private key. Arguments : message str - The message to sign. private_key int - The private key used for signing. Returns : str - The base64-encoded signature.","title":"sign"},{"location":"encryption/#verify","text":"def verify(message: str, signature: str, public_key: str) -> bool Verifies an ECDSA signature using a public key. Arguments : message str - The signed message. signature str - The base64-encoded signature. public_key str - The base64-encoded public key. Returns : bool - True if the signature is valid, False otherwise.","title":"verify"},{"location":"encryption/#aes_encrypt","text":"def aes_encrypt(data: str, secret: str) -> str Encrypts data using AES with a secret. Arguments : data str - The plaintext data to encrypt. secret str - The secret key for encryption. Returns : str - The encrypted data as a hexadecimal string.","title":"aes_encrypt"},{"location":"encryption/#aes_decrypt","text":"def aes_decrypt(data: str, secret: str) -> str Decrypts AES-encrypted data using a secret. Arguments : data str - The encrypted data as a hexadecimal string. secret str - The secret key for decryption. Returns : str|bool - The decrypted plaintext data, or False if decryption fails.","title":"aes_decrypt"},{"location":"encryption/#encrypt","text":"def encrypt(public_key: str, message: str) -> typing.Tuple[str, str] Encrypts a message using a public key. Arguments : public_key str - The base64-encoded public key. message str - The plaintext message to encrypt. Returns : tuple - A tuple containing the base64-encoded R value and the encrypted message as a hexadecimal string.","title":"encrypt"},{"location":"encryption/#decrypt","text":"def decrypt(private_key: int, R: str, ciphered: str) -> str Decrypts a message using a private key. Arguments : private_key int - The base64-encoded private key. R str - The base64-encoded ephemeral public key. ciphered str - The ciphered message to decrypt. Returns : str - Message as plaintext.","title":"decrypt"},{"location":"request/","text":"req This module is designed to handle common HTTP operations in a clean and reusable manner, with dynamic endpoint resolution and robust response management. Let\u2019s run a micro server: # test.py from usrv import route # allow req.Endpoint.connect @route.bind(\"/\", methods=[\"HEAD\"]) def base(): return 200, # public key endoint for encryption @route.bind(\"/puk\", methods=[\"GET\"]) def puk(): return 200, route.PUBLIC_KEY @route.bind(\"/index\") def index(*args): return (200, ) + args @route.bind(\"/api/endpoint\", methods=[\"GET\", \"POST\"]) def endpoit(a, b, **kwargs): method = kwargs[\"method\"] if method == \"POST\": return 202, kwargs[\"data\"] elif method == \"GET\": return 200, a, b else: return 404, route.run(host='127.0.0.1', port=5000) $ python path/to/test.py INFO:usrv:listening on http://127.0.0.1:5000 CTRL+C to stop... Connect to a peer Remote path / allows HEAD request: >>> from usrv import req >>> req.Endpoint.connect(\"http://127.0.0.1:5000\") 200 Else, maunally set peer to req.Endpoint or use _peer keyword on each request : >>> from usrv import req >>> req.ENDPOINT.peer = \"http://127.0.0.1:5000\" >>> # or >>> req.GET.api.endpoint(_peer=\"http://127.0.0.1:5000\") >>> req.POST.api.endpoint(_peer=\"http://127.0.0.1:5000\") >>> # ... Endpoints >>> # GET http://127.0.0.1:5000/puk >>> req.GET.puk() [\"pP15aGDcFoqGTHTReiIfEvUcQ2c3AQjYcgCeLgKhpa38Rsub69i6RifuYPGtOOyld7j6y0LP6i0aqBuFYcSmTQ==\"] >>> # GET http://127.0.0.1:5000/api/endpoints?a=12&b=test >>> req.GET.api.endpoint(a=12, b=\"test\") [\"12\", \"test\"] >>> # POST data to http://127.0.0.1:5000/api/endpoints >>> req.POST.api.endpoint(value1=1, value2=2) ['{\"value1\": 1, \"value2\": 2}'] Encrypt HTTP body >>> # encrypt only server body response >>> req.POST.api.endpoint( ... value1=1, value2=2, _headers={\"Sender-Public-Key:req.PUBLIC_KEY} ... ) ['{\"value1\": 1, \"value2\": 2}'] >>> # encrypt request and response bodies >>> puk = req.GET.puk()[0] >>> puk pP15aGDcFoqGTHTReiIfEvUcQ2c3AQjYcgCeLgKhpa38Rsub69i6RifuYPGtOOyld7j6y0LP6i0aqBuFYcSmTQ== >>> req.POST.api.endpoint(value1=1, value2=2, _puk=puk) ['{\"value1\": 1, \"value2\": 2}'] >>> from usrv import secp256k1 >>> # generate a random keypair >>> prk, puk = secp256k1.generate_keypair() >>> # target public key is not server public key >>> puk == req.GET.puk()[0] False >>> print(req.POST.api.endpoints(value1=1, value2=2, _puk=puk)) <!DOCTYPE HTML> <html lang=\"en\"> <head> <meta charset=\"utf-8\"> <title>Error response</title> </head> <body> <h1>Error response</h1> <p>Error code: 500</p> <p>Message: Encryption error.</p> <p>Error code explanation: 5e234e6f68f30a056c2bd53e97b785e49895b1ae85d3cf323a95ot encrypted for public key pP15aGDcFoqGTHTReiIfEvUcQ2c3AQjYcgCeLgKhpa38Rsub69i6RifuYPGtOOyld7j6y0LP6i0aqBuFYcSmTQ==.</p> </body> </html> >>> req.POST.api.endpoint( ... value1=1, value2=2, _headers={\"Sender-Public-Key\":puk} ... ) ERROR:usrv:Encryption error: cc72124506d28ccb7bda70d6649f3f007bca1b8f1d829b047267ea543aa34c96ab39 not encrypted for public key pP15aGDcFoqGTHTReiIfEvUcQ2c3AQjYcgCeLgKhpa38Rsub69i6RifuYPGtOOyld7j6y0LP6i0aqBuFYcSmTQ== 'cc72124506d28ccb7bda70d6649f3f007bca1b8f1d829b047267ea543aa34c96ab39' >>> build_request def build_request(method: str = \"GET\", path: str = \"/\", **kwargs) -> Request Builds an HTTP request object. Arguments : method str - HTTP method (e.g., \u2018GET\u2019, \u2018POST\u2019). Defaults to \u2018GET\u2019. path str - URL path for the request. Defaults to \u2018/\u2019. **kwargs - Additional keyword arguments for query parameters, headers, and data. Returns : Request - Configured HTTP request object. manage_response def manage_response(resp: HTTPResponse) -> typing.Union[dict, str] Parses the HTTP response. Arguments : resp HTTPResponse - HTTP response object. Returns : typing.Union[dict, str]: Decoded response content. RequestCache Objects class RequestCache() Cache manager for HTTP Request objects. RequestCache.__init__ def __init__(max_size: int = 100, ttl: int = 300) Initialize the cache. Arguments : max_size int - Maximum number of entries in the cache. ttl int - Time-to-live for cache entries in seconds. RequestCache.generate_key @staticmethod def generate_key(method: str, path: str, **kwargs) -> str Generate a unique cache key for a request. RequestCache.get def get(key: str) -> typing.Union[None, typing.Tuple[int, Request]] Retrieve an entry from the cache. RequestCache.set def set(key: str, request: Request) -> None Add an entry to the cache. Endpoint Objects class Endpoint() Represents an HTTP endpoint with dynamic attribute handling. Attributes : startswith_ re.Pattern - Pattern to match internal attributes. timeout int - Default timeout for requests. opener OpenerDirector - Opener to handle HTTP requests. peer str - Base URL for the endpoint. Endpoint.__init__ def __init__(master: typing.Any = None, name: str = \"\", method: Callable = manage_response) -> None Initializes an Endpoint instance. Arguments : master typing.Any - Parent endpoint. name str - Name of the current endpoint. method Callable - Request-building method. Endpoint.__getattr__ def __getattr__(attr: str) -> typing.Any Dynamically resolves sub-endpoints. Arguments : attr str - Attribute name. Returns : Endpoint - New sub-endpoint instance. Endpoint.__call__ def __call__(**kwargs) -> typing.Any Executes the endpoint\u2019s method with provided arguments. Arguments : **kwargs - Parameters for the HTTP request. Returns : typing.Any - value returned by method attribute. Endpoint.connect @staticmethod def connect(peer: str) -> typing.Union[int, bool] Tests connection to a peer endpoint and store it if success. Arguments : peer str - Peer URL to test. Returns : typing.Union[int, bool]: HTTP status code or False on failure. build_endpoint def build_endpoint(http_req: str = \"GET\", encoder: Callable = json.dumps, timeout: int = Endpoint.timeout) -> Endpoint Creates a root endpoint. Arguments : http_req str - Name of HTTP method (i.e. HEAD, GET, POST etc\u2026). encoder Callable - Data encoder function to use. timeout int - Request timeout in seconds. Returns : Endpoint - Root endpoint.","title":"Request"},{"location":"request/#req","text":"This module is designed to handle common HTTP operations in a clean and reusable manner, with dynamic endpoint resolution and robust response management. Let\u2019s run a micro server: # test.py from usrv import route # allow req.Endpoint.connect @route.bind(\"/\", methods=[\"HEAD\"]) def base(): return 200, # public key endoint for encryption @route.bind(\"/puk\", methods=[\"GET\"]) def puk(): return 200, route.PUBLIC_KEY @route.bind(\"/index\") def index(*args): return (200, ) + args @route.bind(\"/api/endpoint\", methods=[\"GET\", \"POST\"]) def endpoit(a, b, **kwargs): method = kwargs[\"method\"] if method == \"POST\": return 202, kwargs[\"data\"] elif method == \"GET\": return 200, a, b else: return 404, route.run(host='127.0.0.1', port=5000) $ python path/to/test.py INFO:usrv:listening on http://127.0.0.1:5000 CTRL+C to stop... Connect to a peer Remote path / allows HEAD request: >>> from usrv import req >>> req.Endpoint.connect(\"http://127.0.0.1:5000\") 200 Else, maunally set peer to req.Endpoint or use _peer keyword on each request : >>> from usrv import req >>> req.ENDPOINT.peer = \"http://127.0.0.1:5000\" >>> # or >>> req.GET.api.endpoint(_peer=\"http://127.0.0.1:5000\") >>> req.POST.api.endpoint(_peer=\"http://127.0.0.1:5000\") >>> # ... Endpoints >>> # GET http://127.0.0.1:5000/puk >>> req.GET.puk() [\"pP15aGDcFoqGTHTReiIfEvUcQ2c3AQjYcgCeLgKhpa38Rsub69i6RifuYPGtOOyld7j6y0LP6i0aqBuFYcSmTQ==\"] >>> # GET http://127.0.0.1:5000/api/endpoints?a=12&b=test >>> req.GET.api.endpoint(a=12, b=\"test\") [\"12\", \"test\"] >>> # POST data to http://127.0.0.1:5000/api/endpoints >>> req.POST.api.endpoint(value1=1, value2=2) ['{\"value1\": 1, \"value2\": 2}'] Encrypt HTTP body >>> # encrypt only server body response >>> req.POST.api.endpoint( ... value1=1, value2=2, _headers={\"Sender-Public-Key:req.PUBLIC_KEY} ... ) ['{\"value1\": 1, \"value2\": 2}'] >>> # encrypt request and response bodies >>> puk = req.GET.puk()[0] >>> puk pP15aGDcFoqGTHTReiIfEvUcQ2c3AQjYcgCeLgKhpa38Rsub69i6RifuYPGtOOyld7j6y0LP6i0aqBuFYcSmTQ== >>> req.POST.api.endpoint(value1=1, value2=2, _puk=puk) ['{\"value1\": 1, \"value2\": 2}'] >>> from usrv import secp256k1 >>> # generate a random keypair >>> prk, puk = secp256k1.generate_keypair() >>> # target public key is not server public key >>> puk == req.GET.puk()[0] False >>> print(req.POST.api.endpoints(value1=1, value2=2, _puk=puk)) <!DOCTYPE HTML> <html lang=\"en\"> <head> <meta charset=\"utf-8\"> <title>Error response</title> </head> <body> <h1>Error response</h1> <p>Error code: 500</p> <p>Message: Encryption error.</p> <p>Error code explanation: 5e234e6f68f30a056c2bd53e97b785e49895b1ae85d3cf323a95ot encrypted for public key pP15aGDcFoqGTHTReiIfEvUcQ2c3AQjYcgCeLgKhpa38Rsub69i6RifuYPGtOOyld7j6y0LP6i0aqBuFYcSmTQ==.</p> </body> </html> >>> req.POST.api.endpoint( ... value1=1, value2=2, _headers={\"Sender-Public-Key\":puk} ... ) ERROR:usrv:Encryption error: cc72124506d28ccb7bda70d6649f3f007bca1b8f1d829b047267ea543aa34c96ab39 not encrypted for public key pP15aGDcFoqGTHTReiIfEvUcQ2c3AQjYcgCeLgKhpa38Rsub69i6RifuYPGtOOyld7j6y0LP6i0aqBuFYcSmTQ== 'cc72124506d28ccb7bda70d6649f3f007bca1b8f1d829b047267ea543aa34c96ab39' >>>","title":"req"},{"location":"request/#build_request","text":"def build_request(method: str = \"GET\", path: str = \"/\", **kwargs) -> Request Builds an HTTP request object. Arguments : method str - HTTP method (e.g., \u2018GET\u2019, \u2018POST\u2019). Defaults to \u2018GET\u2019. path str - URL path for the request. Defaults to \u2018/\u2019. **kwargs - Additional keyword arguments for query parameters, headers, and data. Returns : Request - Configured HTTP request object.","title":"build_request"},{"location":"request/#manage_response","text":"def manage_response(resp: HTTPResponse) -> typing.Union[dict, str] Parses the HTTP response. Arguments : resp HTTPResponse - HTTP response object. Returns : typing.Union[dict, str]: Decoded response content.","title":"manage_response"},{"location":"request/#requestcache-objects","text":"class RequestCache() Cache manager for HTTP Request objects.","title":"RequestCache Objects"},{"location":"request/#requestcache__init__","text":"def __init__(max_size: int = 100, ttl: int = 300) Initialize the cache. Arguments : max_size int - Maximum number of entries in the cache. ttl int - Time-to-live for cache entries in seconds.","title":"RequestCache.__init__"},{"location":"request/#requestcachegenerate_key","text":"@staticmethod def generate_key(method: str, path: str, **kwargs) -> str Generate a unique cache key for a request.","title":"RequestCache.generate_key"},{"location":"request/#requestcacheget","text":"def get(key: str) -> typing.Union[None, typing.Tuple[int, Request]] Retrieve an entry from the cache.","title":"RequestCache.get"},{"location":"request/#requestcacheset","text":"def set(key: str, request: Request) -> None Add an entry to the cache.","title":"RequestCache.set"},{"location":"request/#endpoint-objects","text":"class Endpoint() Represents an HTTP endpoint with dynamic attribute handling. Attributes : startswith_ re.Pattern - Pattern to match internal attributes. timeout int - Default timeout for requests. opener OpenerDirector - Opener to handle HTTP requests. peer str - Base URL for the endpoint.","title":"Endpoint Objects"},{"location":"request/#endpoint__init__","text":"def __init__(master: typing.Any = None, name: str = \"\", method: Callable = manage_response) -> None Initializes an Endpoint instance. Arguments : master typing.Any - Parent endpoint. name str - Name of the current endpoint. method Callable - Request-building method.","title":"Endpoint.__init__"},{"location":"request/#endpoint__getattr__","text":"def __getattr__(attr: str) -> typing.Any Dynamically resolves sub-endpoints. Arguments : attr str - Attribute name. Returns : Endpoint - New sub-endpoint instance.","title":"Endpoint.__getattr__"},{"location":"request/#endpoint__call__","text":"def __call__(**kwargs) -> typing.Any Executes the endpoint\u2019s method with provided arguments. Arguments : **kwargs - Parameters for the HTTP request. Returns : typing.Any - value returned by method attribute.","title":"Endpoint.__call__"},{"location":"request/#endpointconnect","text":"@staticmethod def connect(peer: str) -> typing.Union[int, bool] Tests connection to a peer endpoint and store it if success. Arguments : peer str - Peer URL to test. Returns : typing.Union[int, bool]: HTTP status code or False on failure.","title":"Endpoint.connect"},{"location":"request/#build_endpoint","text":"def build_endpoint(http_req: str = \"GET\", encoder: Callable = json.dumps, timeout: int = Endpoint.timeout) -> Endpoint Creates a root endpoint. Arguments : http_req str - Name of HTTP method (i.e. HEAD, GET, POST etc\u2026). encoder Callable - Data encoder function to use. timeout int - Request timeout in seconds. Returns : Endpoint - Root endpoint.","title":"build_endpoint"},{"location":"serving/","text":"app This module contains all the utilities to launch a WSGI micro server (highly recommended in production mode). uApp Objects class uApp() Represents a lightweight application server that can handle HTTP requests, optionally wrap its socket with SSL, and run in a testing mode. Attributes : handler BaseHTTPRequestHandler - HTTP request handler. host str - The hostname for the server. port int - The port number for the server. uApp.__init__ def __init__(host: str = \"127.0.0.1\", port: int = 5000, loglevel: int = 20, handler: BaseHTTPRequestHandler = route.uHTTPRequestHandler) Initializes the uApp instance with a specified host, port, logging level, and request handler. Arguments : host str - Hostname for the server. Defaults to \u201c127.0.0.1\u201d. port int - Port number for the server. Defaults to 5000. loglevel int - Logging level. Defaults to 20 (INFO). handler BaseHTTPRequestHandler - Request handler. Defaults to route.uHTTPRequestHandler . uApp.__call__ def __call__(environ: dict, start_response: Callable) -> bytes Enables the application to be callable as a WSGI application. Arguments : environ dict - The WSGI environment dictionary. start_response callable - A callable to start the HTTP response. Returns : Callable - The response iterable. uApp.wrap def wrap() -> bool Wraps the HTTP server\u2019s socket with SSL if a certificate and key are available. Returns : bool - True if the socket is successfully wrapped with SSL, False otherwise. uApp.run def run(ssl: bool = False) Starts the HTTP server, optionally wrapping the socket with SSL. This method is designed for testing purposes only. Arguments : ssl bool - If True, wraps the server\u2019s socket with SSL. Defaults to False.","title":"Serving"},{"location":"serving/#app","text":"This module contains all the utilities to launch a WSGI micro server (highly recommended in production mode).","title":"app"},{"location":"serving/#uapp-objects","text":"class uApp() Represents a lightweight application server that can handle HTTP requests, optionally wrap its socket with SSL, and run in a testing mode. Attributes : handler BaseHTTPRequestHandler - HTTP request handler. host str - The hostname for the server. port int - The port number for the server.","title":"uApp Objects"},{"location":"serving/#uapp__init__","text":"def __init__(host: str = \"127.0.0.1\", port: int = 5000, loglevel: int = 20, handler: BaseHTTPRequestHandler = route.uHTTPRequestHandler) Initializes the uApp instance with a specified host, port, logging level, and request handler. Arguments : host str - Hostname for the server. Defaults to \u201c127.0.0.1\u201d. port int - Port number for the server. Defaults to 5000. loglevel int - Logging level. Defaults to 20 (INFO). handler BaseHTTPRequestHandler - Request handler. Defaults to route.uHTTPRequestHandler .","title":"uApp.__init__"},{"location":"serving/#uapp__call__","text":"def __call__(environ: dict, start_response: Callable) -> bytes Enables the application to be callable as a WSGI application. Arguments : environ dict - The WSGI environment dictionary. start_response callable - A callable to start the HTTP response. Returns : Callable - The response iterable.","title":"uApp.__call__"},{"location":"serving/#uappwrap","text":"def wrap() -> bool Wraps the HTTP server\u2019s socket with SSL if a certificate and key are available. Returns : bool - True if the socket is successfully wrapped with SSL, False otherwise.","title":"uApp.wrap"},{"location":"serving/#uapprun","text":"def run(ssl: bool = False) Starts the HTTP server, optionally wrapping the socket with SSL. This method is designed for testing purposes only. Arguments : ssl bool - If True, wraps the server\u2019s socket with SSL. Defaults to False.","title":"uApp.run"}]}