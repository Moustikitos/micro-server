{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"usrv : the lightest python server Package ( usrv ) is a pure python micro server implementation. Install $ pip install git+https://github.com/Moustikitos/micro-server#egg=usrv usrv.route Bind python code to any HTTP requests easily using decorator syntax. route module can be used in standalone mode outside of usrv package. usrv.app Run a low footprint python server or PEP#3333 WSGI server . import waitress # wsgi server for windows from usrv import app, route @route.bind(\"/index\") def index(**kw): return 200, \"Index page\", kw waitress.serve(app.uApp(), threads=2) Fast and simple Let\u2019s create a server with /test endpoint in a python module named test.py : from usrv import route, app @route.bind(\"/test\") def do_test(a, b): # write some code and return something return 200, a, b def launchApp(): route.run(host=\"127.0.0.1\", port=5000, loglevel=20) Bound functions have to return a tuple with a valid HTTP status code as first item . Server can be run from python interpreter: >>> import test >>> test.launchApp() INFO:usrv.srv:listening on 127.0.0.1:5000 CTRL+C to stop... Now going to http://127.0.0.1:5000/test with any browser gives: [null, null] Extracting values from url query [null, null] above are the returned values a and b from do_test function. Values can be extracted from query string. Let\u2019s type http://127.0.0.1:5000/test?b=12&a=Paris in the address bar: [\"Paris\", \"12\"] Returned value from query are str only. Unexpected values are ignored but there is a convenient way to catch them . Extracting values from url path Values can also be extracted from url path with or without a typing precision. @srv.bind(\"/<int:b>/<a>\") def do_test(a, b): # write some code and return something return 200, a, b This binding creates multiple endpoint possibilities. Let\u2019s try http://127.0.0.1:5000/5/test : [\"test\", 5] Values from url can be overrided by thoses from query\u2026 http://127.0.0.1:5000/5/test?a=2&b=6 : [\"2\", \"6\"] It can only be overrided with str type values. Catching unexpected values Using varargs or/and keywordargs is a convenient way to catch unexpected values from url query and HTTP context. HTTP Context is defined an headers and data (HTTP requests with body). When HTTP context is catched by *args , unexpected values from query string are appended next. Url used for this chapter http://127.0.0.1:5000/test?b=12&a=Paris&unexpected=there . Variable args ( *args ) @srv.bind(\"/test\") def do_test(a, b, *args): # write some code and return something # args is a tuple return 200, a, b, args With *args method, HTTP headers and data will be postionned at the end of json response [ \"Paris\", \"12\", \"there\", \"GET\", { \"host\": \"127.0.0.1:5000\", \"connection\": \"keep-alive\", \"sec-ch-ua\": \"\\\"Brave\\\";v=\\\"131\\\", \\\"Chromium\\\";v=\\\"131\\\", \\\"Not_A Brand\\\";v=\\\"24\\\"\", \"sec-ch-ua-mobile\": \"?0\", \"sec-ch-ua-platform\": \"\\\"Windows\\\"\", \"upgrade-insecure-requests\": \"1\", \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36\", \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8\", \"sec-gpc\": \"1\", \"accept-language\": \"fr-FR,fr\", \"sec-fetch-site\": \"none\", \"sec-fetch-mode\": \"navigate\", \"sec-fetch-user\": \"?1\", \"sec-fetch-dest\": \"document\", \"accept-encoding\": \"gzip, deflate, br, zstd\" }, null ] Keyword args ( **kwargs ) @srv.bind(\"/test\") def do_test(a, b, **kwargs): # write some code and return something # kwargs is a dict return 200, a, b, kwargs using **kwargs is the recommended way to retrieve unexpected values by names. Unexpected mapping is positionned at the end of json response. [ \"Paris\", \"12\", { \"unexpected\": \"there\", \"method\": \"GET\", \"headers\": { \"host\": \"127.0.0.1:5000\", \"connection\": \"keep-alive\", \"sec-ch-ua\": \"\\\"Brave\\\";v=\\\"131\\\", \\\"Chromium\\\";v=\\\"131\\\", \\\"Not_A Brand\\\";v=\\\"24\\\"\", \"sec-ch-ua-mobile\": \"?0\", \"sec-ch-ua-platform\": \"\\\"Windows\\\"\", \"upgrade-insecure-requests\": \"1\", \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36\", \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8\", \"sec-gpc\": \"1\", \"accept-language\": \"fr-FR,fr\", \"sec-fetch-site\": \"none\", \"sec-fetch-mode\": \"navigate\", \"sec-fetch-user\": \"?1\", \"sec-fetch-dest\": \"document\", \"accept-encoding\": \"gzip, deflate, br, zstd\" }, \"data\": null, } ] Command line WSGI server can be launched from command line. $ python wsgi_srv.py -h Usage: wsgi_srv.py [options] BINDINGS... Options: --version show program's version number and exit -h, --help show this help message and exit -t THREADS, --threads=THREADS set thread number [default: 2] -l LOGLEVEL, --log-level=LOGLEVEL set log level from 1 to 100 [default: 20] -i HOST, --ip=HOST ip to run from [default: 127.0.0.1] -p PORT, --port=PORT port to use [default: 5000] BINDINGS is a space-separated-list of python module names (ie no *.py extention) containing boud python functions. Modules containing bound functions have to be in one of sys.path folder. Specific folder can be added using wsgi_srv.path file. Support this project","title":"Home"},{"location":"#usrv-the-lightest-python-server","text":"Package ( usrv ) is a pure python micro server implementation.","title":"usrv: the lightest python server"},{"location":"#install","text":"$ pip install git+https://github.com/Moustikitos/micro-server#egg=usrv","title":"Install"},{"location":"#usrvroute","text":"Bind python code to any HTTP requests easily using decorator syntax. route module can be used in standalone mode outside of usrv package.","title":"usrv.route"},{"location":"#usrvapp","text":"Run a low footprint python server or PEP#3333 WSGI server . import waitress # wsgi server for windows from usrv import app, route @route.bind(\"/index\") def index(**kw): return 200, \"Index page\", kw waitress.serve(app.uApp(), threads=2)","title":"usrv.app"},{"location":"#fast-and-simple","text":"Let\u2019s create a server with /test endpoint in a python module named test.py : from usrv import route, app @route.bind(\"/test\") def do_test(a, b): # write some code and return something return 200, a, b def launchApp(): route.run(host=\"127.0.0.1\", port=5000, loglevel=20) Bound functions have to return a tuple with a valid HTTP status code as first item . Server can be run from python interpreter: >>> import test >>> test.launchApp() INFO:usrv.srv:listening on 127.0.0.1:5000 CTRL+C to stop... Now going to http://127.0.0.1:5000/test with any browser gives: [null, null]","title":"Fast and simple"},{"location":"#extracting-values-from-url-query","text":"[null, null] above are the returned values a and b from do_test function. Values can be extracted from query string. Let\u2019s type http://127.0.0.1:5000/test?b=12&a=Paris in the address bar: [\"Paris\", \"12\"] Returned value from query are str only. Unexpected values are ignored but there is a convenient way to catch them .","title":"Extracting values from url query"},{"location":"#extracting-values-from-url-path","text":"Values can also be extracted from url path with or without a typing precision. @srv.bind(\"/<int:b>/<a>\") def do_test(a, b): # write some code and return something return 200, a, b This binding creates multiple endpoint possibilities. Let\u2019s try http://127.0.0.1:5000/5/test : [\"test\", 5] Values from url can be overrided by thoses from query\u2026 http://127.0.0.1:5000/5/test?a=2&b=6 : [\"2\", \"6\"] It can only be overrided with str type values.","title":"Extracting values from url path"},{"location":"#catching-unexpected-values","text":"Using varargs or/and keywordargs is a convenient way to catch unexpected values from url query and HTTP context. HTTP Context is defined an headers and data (HTTP requests with body). When HTTP context is catched by *args , unexpected values from query string are appended next. Url used for this chapter http://127.0.0.1:5000/test?b=12&a=Paris&unexpected=there .","title":"Catching unexpected values"},{"location":"#variable-args-args","text":"@srv.bind(\"/test\") def do_test(a, b, *args): # write some code and return something # args is a tuple return 200, a, b, args With *args method, HTTP headers and data will be postionned at the end of json response [ \"Paris\", \"12\", \"there\", \"GET\", { \"host\": \"127.0.0.1:5000\", \"connection\": \"keep-alive\", \"sec-ch-ua\": \"\\\"Brave\\\";v=\\\"131\\\", \\\"Chromium\\\";v=\\\"131\\\", \\\"Not_A Brand\\\";v=\\\"24\\\"\", \"sec-ch-ua-mobile\": \"?0\", \"sec-ch-ua-platform\": \"\\\"Windows\\\"\", \"upgrade-insecure-requests\": \"1\", \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36\", \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8\", \"sec-gpc\": \"1\", \"accept-language\": \"fr-FR,fr\", \"sec-fetch-site\": \"none\", \"sec-fetch-mode\": \"navigate\", \"sec-fetch-user\": \"?1\", \"sec-fetch-dest\": \"document\", \"accept-encoding\": \"gzip, deflate, br, zstd\" }, null ]","title":"Variable args (*args)"},{"location":"#keyword-args-kwargs","text":"@srv.bind(\"/test\") def do_test(a, b, **kwargs): # write some code and return something # kwargs is a dict return 200, a, b, kwargs using **kwargs is the recommended way to retrieve unexpected values by names. Unexpected mapping is positionned at the end of json response. [ \"Paris\", \"12\", { \"unexpected\": \"there\", \"method\": \"GET\", \"headers\": { \"host\": \"127.0.0.1:5000\", \"connection\": \"keep-alive\", \"sec-ch-ua\": \"\\\"Brave\\\";v=\\\"131\\\", \\\"Chromium\\\";v=\\\"131\\\", \\\"Not_A Brand\\\";v=\\\"24\\\"\", \"sec-ch-ua-mobile\": \"?0\", \"sec-ch-ua-platform\": \"\\\"Windows\\\"\", \"upgrade-insecure-requests\": \"1\", \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36\", \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8\", \"sec-gpc\": \"1\", \"accept-language\": \"fr-FR,fr\", \"sec-fetch-site\": \"none\", \"sec-fetch-mode\": \"navigate\", \"sec-fetch-user\": \"?1\", \"sec-fetch-dest\": \"document\", \"accept-encoding\": \"gzip, deflate, br, zstd\" }, \"data\": null, } ]","title":"Keyword args (**kwargs)"},{"location":"#command-line","text":"WSGI server can be launched from command line. $ python wsgi_srv.py -h Usage: wsgi_srv.py [options] BINDINGS... Options: --version show program's version number and exit -h, --help show this help message and exit -t THREADS, --threads=THREADS set thread number [default: 2] -l LOGLEVEL, --log-level=LOGLEVEL set log level from 1 to 100 [default: 20] -i HOST, --ip=HOST ip to run from [default: 127.0.0.1] -p PORT, --port=PORT port to use [default: 5000] BINDINGS is a space-separated-list of python module names (ie no *.py extention) containing boud python functions. Modules containing bound functions have to be in one of sys.path folder. Specific folder can be added using wsgi_srv.path file.","title":"Command line"},{"location":"#support-this-project","text":"","title":"Support this project"},{"location":"bindings/","text":"route This module contains all the utilities to launch a micro server from python lib. It is not recommended to use it in production mode. $ python route.py -h Usage: route.py [options] BINDINGS... Options: --version show program's version number and exit -h, --help show this help message and exit -t THREADS, --threads=THREADS set thread number [default: 2] -l LOGLEVEL, --log-level=LOGLEVEL set log level from 1 to 100 [default: 20] -i HOST, --ip=HOST ip to run from [default: 127.0.0.1] -p PORT, --port=PORT port to use [default: 5000] BINDINGS is a list of python modules containing python bound functions. Endpoint Objects class Endpoint() Placeholder for storing endpoint mappings. EndpointAlreadyDefined Objects class EndpointAlreadyDefined(Exception) Exception raised when an endpoint is already defined. UrlMatchError Objects class UrlMatchError(Exception) Exception raised for errors in URL pattern matching. uHTTPRequestHandler Objects class uHTTPRequestHandler(BaseHTTPRequestHandler) Custom HTTP request handler that handles HTTP methods dynamically. Methods : format_response - Formats the response as JSON. do_ - Processes HTTP requests based on registered endpoints. uHTTPRequestHandler.__getattr__ def __getattr__(attr: str) -> Callable Dynamically handles HTTP methods like \u2018do_GET\u2019, \u2018do_POST\u2019, etc. Arguments : attr str - The attribute name. Returns : Callable - The dynamic handler function. uHTTPRequestHandler.format_response @staticmethod def format_response(resp: typing.Any) -> typing.Tuple[str, str] Formats a response as JSON. Arguments : resp Any - The response data. Returns : Tuple[str, str]: The JSON response and its content type. uHTTPRequestHandler.do_ def do_(method: str = \"GET\") -> int Processes an HTTP request and calls the appropriate endpoint. Arguments : method str - The HTTP method (e.g., \u201cGET\u201d, \u201cPOST\u201d). Defaults to \u201cGET\u201d. Returns : int - Status code of the response. bind def bind(path: str, methods: list = [\"GET\"], target: BaseHTTPRequestHandler = uHTTPRequestHandler) -> Callable Binds a function to a specific URL path and HTTP methods. Arguments : path str - The URL path to bind. methods list - List of HTTP methods (e.g., [\u201cGET\u201d, \u201cPOST\u201d]). target BaseHTTPRequestHandler - The request handler class. Returns : Callable - A decorator that binds the function. callback def callback(url: str, headers: dict, data: str, function: Callable, method: str, markups: OrderedDict, regexp: re.Pattern, arg_spec: inspect.FullArgSpec) -> typing.Any Handles the execution of the bound function with appropriate arguments. the last 4 parameters are defined by the bind function and stored in the lambda callback. Arguments : url str - The full URL of the request. headers dict - The HTTP headers from the request. data str - The body of the request. function Callable - The function to execute. method str - The HTTP command used. markups OrderedDict - Mappings of path variables to their types. regexp re.Pattern - Compiled regex for path matching. arg_spec FixArgSpec - Argument specification of the function. Returns : Any - The result of the function execution. run def run(host: str = \"127.0.0.1\", port: int = 5000, loglevel: int = 20) -> None Starts the HTTP server. Arguments : host str - The IP address to bind to. Defaults to \u201c127.0.0.1\u201d. port int - The port to bind to. Defaults to 5000. loglevel int - Logging level. Defaults to 20.","title":"Bindings"},{"location":"bindings/#route","text":"This module contains all the utilities to launch a micro server from python lib. It is not recommended to use it in production mode. $ python route.py -h Usage: route.py [options] BINDINGS... Options: --version show program's version number and exit -h, --help show this help message and exit -t THREADS, --threads=THREADS set thread number [default: 2] -l LOGLEVEL, --log-level=LOGLEVEL set log level from 1 to 100 [default: 20] -i HOST, --ip=HOST ip to run from [default: 127.0.0.1] -p PORT, --port=PORT port to use [default: 5000] BINDINGS is a list of python modules containing python bound functions.","title":"route"},{"location":"bindings/#endpoint-objects","text":"class Endpoint() Placeholder for storing endpoint mappings.","title":"Endpoint Objects"},{"location":"bindings/#endpointalreadydefined-objects","text":"class EndpointAlreadyDefined(Exception) Exception raised when an endpoint is already defined.","title":"EndpointAlreadyDefined Objects"},{"location":"bindings/#urlmatcherror-objects","text":"class UrlMatchError(Exception) Exception raised for errors in URL pattern matching.","title":"UrlMatchError Objects"},{"location":"bindings/#uhttprequesthandler-objects","text":"class uHTTPRequestHandler(BaseHTTPRequestHandler) Custom HTTP request handler that handles HTTP methods dynamically. Methods : format_response - Formats the response as JSON. do_ - Processes HTTP requests based on registered endpoints.","title":"uHTTPRequestHandler Objects"},{"location":"bindings/#uhttprequesthandler__getattr__","text":"def __getattr__(attr: str) -> Callable Dynamically handles HTTP methods like \u2018do_GET\u2019, \u2018do_POST\u2019, etc. Arguments : attr str - The attribute name. Returns : Callable - The dynamic handler function.","title":"uHTTPRequestHandler.__getattr__"},{"location":"bindings/#uhttprequesthandlerformat_response","text":"@staticmethod def format_response(resp: typing.Any) -> typing.Tuple[str, str] Formats a response as JSON. Arguments : resp Any - The response data. Returns : Tuple[str, str]: The JSON response and its content type.","title":"uHTTPRequestHandler.format_response"},{"location":"bindings/#uhttprequesthandlerdo_","text":"def do_(method: str = \"GET\") -> int Processes an HTTP request and calls the appropriate endpoint. Arguments : method str - The HTTP method (e.g., \u201cGET\u201d, \u201cPOST\u201d). Defaults to \u201cGET\u201d. Returns : int - Status code of the response.","title":"uHTTPRequestHandler.do_"},{"location":"bindings/#bind","text":"def bind(path: str, methods: list = [\"GET\"], target: BaseHTTPRequestHandler = uHTTPRequestHandler) -> Callable Binds a function to a specific URL path and HTTP methods. Arguments : path str - The URL path to bind. methods list - List of HTTP methods (e.g., [\u201cGET\u201d, \u201cPOST\u201d]). target BaseHTTPRequestHandler - The request handler class. Returns : Callable - A decorator that binds the function.","title":"bind"},{"location":"bindings/#callback","text":"def callback(url: str, headers: dict, data: str, function: Callable, method: str, markups: OrderedDict, regexp: re.Pattern, arg_spec: inspect.FullArgSpec) -> typing.Any Handles the execution of the bound function with appropriate arguments. the last 4 parameters are defined by the bind function and stored in the lambda callback. Arguments : url str - The full URL of the request. headers dict - The HTTP headers from the request. data str - The body of the request. function Callable - The function to execute. method str - The HTTP command used. markups OrderedDict - Mappings of path variables to their types. regexp re.Pattern - Compiled regex for path matching. arg_spec FixArgSpec - Argument specification of the function. Returns : Any - The result of the function execution.","title":"callback"},{"location":"bindings/#run","text":"def run(host: str = \"127.0.0.1\", port: int = 5000, loglevel: int = 20) -> None Starts the HTTP server. Arguments : host str - The IP address to bind to. Defaults to \u201c127.0.0.1\u201d. port int - The port to bind to. Defaults to 5000. loglevel int - Logging level. Defaults to 20.","title":"run"},{"location":"request/","text":"req HTTP Client Module This module provides a flexible and extensible framework for building, sending, and managing HTTP requests and responses. It includes support for dynamic endpoints, SSL configuration, and content decoding based on MIME types. Classes RequestCache: a caching service for python HTTP Request. Endpoint: Represents an HTTP endpoint with dynamic attribute handling and customizable request methods. Functions build_request: Constructs HTTP requests with specified parameters and headers. manage_response: Parses and decodes HTTP responses based on their MIME types. Constants CONTEXT: SSL context with disabled hostname verification. DECODERS: Dictionary mapping MIME types to their respective parsers. OPENER: Global HTTP request opener. Endpoints Predefined instances of the Endpoint class for standard HTTP methods: - CONNECT - GET - HEAD - OPTION - PATCH - POST - PUT - TRACE - DELETE This module is designed to handle common HTTP operations in a clean and reusable manner, with dynamic endpoint resolution and robust response management. Let\u2019s run a micro server: from usrv import route # allow req.Endpoint.connect @route.bind(\"/\", methods=[\"HEAD\"]) def base(): return 200, @route.bind(\"/index\") def index(*args): return (200, ) + args @route.bind(\"/api/endpoint\", methods=[\"GET\", \"POST\"]) def endpoit(a, b, **kwargs): method = kwargs[\"method\"] if method == \"POST\": return 202, elif method == \"GET\": return 200, a, b, kwargs else: return 404, route.run(host='127.0.0.1', port=5000) execute simple requests: >>> from usrv import req >>> req.Endpoint.connect(\"http://127.0.0.1:5000\") 200 >>> req.GET.index() [{'accept-encoding': 'identity', 'host': '127.0.0.1:5000', 'user-agent': 'Python/usrv', 'content-type': 'application/json', 'connection': 'close'}, None] >>> req.GET.api.endpoint() [None, None, {'headers': {'accept-encoding': 'identity', 'host': '127.0.0.1:5000', 'user-agent': 'Python/usrv', 'content-type': 'application/json', 'connection': 'close'}, 'data': None}] build_request def build_request(method: str = \"GET\", path: str = \"/\", **kwargs) -> Request Builds an HTTP request object. Arguments : method str - HTTP method (e.g., \u2018GET\u2019, \u2018POST\u2019). Defaults to \u2018GET\u2019. path str - URL path for the request. Defaults to \u2018/\u2019. **kwargs - Additional keyword arguments for query parameters, headers, and data. Returns : Request - Configured HTTP request object. manage_response def manage_response(resp: HTTPResponse) -> typing.Union[dict, str] Parses the HTTP response. Arguments : resp HTTPResponse - HTTP response object. Returns : typing.Union[dict, str]: Decoded response content. RequestCache Objects class RequestCache() Cache manager for HTTP Request objects. RequestCache.__init__ def __init__(max_size: int = 100, ttl: int = 300) Initialize the cache. Arguments : max_size int - Maximum number of entries in the cache. ttl int - Time-to-live for cache entries in seconds. RequestCache.generate_key @staticmethod def generate_key(method: str, path: str, **kwargs) -> str Generate a unique cache key for a request. RequestCache.get def get(key: str) -> typing.Union[None, typing.Tuple[int, Request]] Retrieve an entry from the cache. RequestCache.set def set(key: str, request: Request) -> None Add an entry to the cache. Endpoint Objects class Endpoint() Represents an HTTP endpoint with dynamic attribute handling. Attributes : startswith_ re.Pattern - Pattern to match internal attributes. timeout int - Default timeout for requests. opener OpenerDirector - Opener to handle HTTP requests. peer str - Base URL for the endpoint. Endpoint.__init__ def __init__(master: typing.Any = None, name: str = \"\", method: Callable = manage_response) -> None Initializes an Endpoint instance. Arguments : master typing.Any - Parent endpoint. name str - Name of the current endpoint. method Callable - Request-building method. Endpoint.__getattr__ def __getattr__(attr: str) -> typing.Any Dynamically resolves sub-endpoints. Arguments : attr str - Attribute name. Returns : Endpoint - New sub-endpoint instance. Endpoint.__call__ def __call__(**kwargs) -> typing.Any Executes the endpoint\u2019s method with provided arguments. Arguments : **kwargs - Parameters for the HTTP request. Returns : typing.Any - value returned by method attribute. Endpoint.connect @staticmethod def connect(peer: str) -> typing.Union[int, bool] Tests connection to a peer endpoint and store it if success. Arguments : peer str - Peer URL to test. Returns : typing.Union[int, bool]: HTTP status code or False on failure.","title":"Request"},{"location":"request/#req","text":"HTTP Client Module This module provides a flexible and extensible framework for building, sending, and managing HTTP requests and responses. It includes support for dynamic endpoints, SSL configuration, and content decoding based on MIME types.","title":"req"},{"location":"request/#classes","text":"RequestCache: a caching service for python HTTP Request. Endpoint: Represents an HTTP endpoint with dynamic attribute handling and customizable request methods.","title":"Classes"},{"location":"request/#functions","text":"build_request: Constructs HTTP requests with specified parameters and headers. manage_response: Parses and decodes HTTP responses based on their MIME types.","title":"Functions"},{"location":"request/#constants","text":"CONTEXT: SSL context with disabled hostname verification. DECODERS: Dictionary mapping MIME types to their respective parsers. OPENER: Global HTTP request opener.","title":"Constants"},{"location":"request/#endpoints","text":"Predefined instances of the Endpoint class for standard HTTP methods: - CONNECT - GET - HEAD - OPTION - PATCH - POST - PUT - TRACE - DELETE This module is designed to handle common HTTP operations in a clean and reusable manner, with dynamic endpoint resolution and robust response management. Let\u2019s run a micro server: from usrv import route # allow req.Endpoint.connect @route.bind(\"/\", methods=[\"HEAD\"]) def base(): return 200, @route.bind(\"/index\") def index(*args): return (200, ) + args @route.bind(\"/api/endpoint\", methods=[\"GET\", \"POST\"]) def endpoit(a, b, **kwargs): method = kwargs[\"method\"] if method == \"POST\": return 202, elif method == \"GET\": return 200, a, b, kwargs else: return 404, route.run(host='127.0.0.1', port=5000) execute simple requests: >>> from usrv import req >>> req.Endpoint.connect(\"http://127.0.0.1:5000\") 200 >>> req.GET.index() [{'accept-encoding': 'identity', 'host': '127.0.0.1:5000', 'user-agent': 'Python/usrv', 'content-type': 'application/json', 'connection': 'close'}, None] >>> req.GET.api.endpoint() [None, None, {'headers': {'accept-encoding': 'identity', 'host': '127.0.0.1:5000', 'user-agent': 'Python/usrv', 'content-type': 'application/json', 'connection': 'close'}, 'data': None}]","title":"Endpoints"},{"location":"request/#build_request","text":"def build_request(method: str = \"GET\", path: str = \"/\", **kwargs) -> Request Builds an HTTP request object. Arguments : method str - HTTP method (e.g., \u2018GET\u2019, \u2018POST\u2019). Defaults to \u2018GET\u2019. path str - URL path for the request. Defaults to \u2018/\u2019. **kwargs - Additional keyword arguments for query parameters, headers, and data. Returns : Request - Configured HTTP request object.","title":"build_request"},{"location":"request/#manage_response","text":"def manage_response(resp: HTTPResponse) -> typing.Union[dict, str] Parses the HTTP response. Arguments : resp HTTPResponse - HTTP response object. Returns : typing.Union[dict, str]: Decoded response content.","title":"manage_response"},{"location":"request/#requestcache-objects","text":"class RequestCache() Cache manager for HTTP Request objects.","title":"RequestCache Objects"},{"location":"request/#requestcache__init__","text":"def __init__(max_size: int = 100, ttl: int = 300) Initialize the cache. Arguments : max_size int - Maximum number of entries in the cache. ttl int - Time-to-live for cache entries in seconds.","title":"RequestCache.__init__"},{"location":"request/#requestcachegenerate_key","text":"@staticmethod def generate_key(method: str, path: str, **kwargs) -> str Generate a unique cache key for a request.","title":"RequestCache.generate_key"},{"location":"request/#requestcacheget","text":"def get(key: str) -> typing.Union[None, typing.Tuple[int, Request]] Retrieve an entry from the cache.","title":"RequestCache.get"},{"location":"request/#requestcacheset","text":"def set(key: str, request: Request) -> None Add an entry to the cache.","title":"RequestCache.set"},{"location":"request/#endpoint-objects","text":"class Endpoint() Represents an HTTP endpoint with dynamic attribute handling. Attributes : startswith_ re.Pattern - Pattern to match internal attributes. timeout int - Default timeout for requests. opener OpenerDirector - Opener to handle HTTP requests. peer str - Base URL for the endpoint.","title":"Endpoint Objects"},{"location":"request/#endpoint__init__","text":"def __init__(master: typing.Any = None, name: str = \"\", method: Callable = manage_response) -> None Initializes an Endpoint instance. Arguments : master typing.Any - Parent endpoint. name str - Name of the current endpoint. method Callable - Request-building method.","title":"Endpoint.__init__"},{"location":"request/#endpoint__getattr__","text":"def __getattr__(attr: str) -> typing.Any Dynamically resolves sub-endpoints. Arguments : attr str - Attribute name. Returns : Endpoint - New sub-endpoint instance.","title":"Endpoint.__getattr__"},{"location":"request/#endpoint__call__","text":"def __call__(**kwargs) -> typing.Any Executes the endpoint\u2019s method with provided arguments. Arguments : **kwargs - Parameters for the HTTP request. Returns : typing.Any - value returned by method attribute.","title":"Endpoint.__call__"},{"location":"request/#endpointconnect","text":"@staticmethod def connect(peer: str) -> typing.Union[int, bool] Tests connection to a peer endpoint and store it if success. Arguments : peer str - Peer URL to test. Returns : typing.Union[int, bool]: HTTP status code or False on failure.","title":"Endpoint.connect"},{"location":"serving/","text":"app This module contains all the utilities to launch a WSGI micro server (highly recommended in production mode). uApp Objects class uApp() Represents a lightweight application server that can handle HTTP requests, optionally wrap its socket with SSL, and run in a testing mode. Attributes : handler BaseHTTPRequestHandler - HTTP request handler. host str - The hostname for the server. port int - The port number for the server. uApp.__init__ def __init__(host: str = \"127.0.0.1\", port: int = 5000, loglevel: int = 20, handler: BaseHTTPRequestHandler = route.uHTTPRequestHandler) Initializes the uApp instance with a specified host, port, logging level, and request handler. Arguments : host str - Hostname for the server. Defaults to \u201c127.0.0.1\u201d. port int - Port number for the server. Defaults to 5000. loglevel int - Logging level. Defaults to 20 (INFO). handler BaseHTTPRequestHandler - Request handler. Defaults to route.uHTTPRequestHandler . uApp.__call__ def __call__(environ: dict, start_response: Callable) -> bytes Enables the application to be callable as a WSGI application. Arguments : environ dict - The WSGI environment dictionary. start_response callable - A callable to start the HTTP response. Returns : Callable - The response iterable. uApp.wrap def wrap() -> bool Wraps the HTTP server\u2019s socket with SSL if a certificate and key are available. Returns : bool - True if the socket is successfully wrapped with SSL, False otherwise. uApp.run def run(ssl: bool = False) Starts the HTTP server, optionally wrapping the socket with SSL. This method is designed for testing purposes only. Arguments : ssl bool - If True, wraps the server\u2019s socket with SSL. Defaults to False.","title":"Serving"},{"location":"serving/#app","text":"This module contains all the utilities to launch a WSGI micro server (highly recommended in production mode).","title":"app"},{"location":"serving/#uapp-objects","text":"class uApp() Represents a lightweight application server that can handle HTTP requests, optionally wrap its socket with SSL, and run in a testing mode. Attributes : handler BaseHTTPRequestHandler - HTTP request handler. host str - The hostname for the server. port int - The port number for the server.","title":"uApp Objects"},{"location":"serving/#uapp__init__","text":"def __init__(host: str = \"127.0.0.1\", port: int = 5000, loglevel: int = 20, handler: BaseHTTPRequestHandler = route.uHTTPRequestHandler) Initializes the uApp instance with a specified host, port, logging level, and request handler. Arguments : host str - Hostname for the server. Defaults to \u201c127.0.0.1\u201d. port int - Port number for the server. Defaults to 5000. loglevel int - Logging level. Defaults to 20 (INFO). handler BaseHTTPRequestHandler - Request handler. Defaults to route.uHTTPRequestHandler .","title":"uApp.__init__"},{"location":"serving/#uapp__call__","text":"def __call__(environ: dict, start_response: Callable) -> bytes Enables the application to be callable as a WSGI application. Arguments : environ dict - The WSGI environment dictionary. start_response callable - A callable to start the HTTP response. Returns : Callable - The response iterable.","title":"uApp.__call__"},{"location":"serving/#uappwrap","text":"def wrap() -> bool Wraps the HTTP server\u2019s socket with SSL if a certificate and key are available. Returns : bool - True if the socket is successfully wrapped with SSL, False otherwise.","title":"uApp.wrap"},{"location":"serving/#uapprun","text":"def run(ssl: bool = False) Starts the HTTP server, optionally wrapping the socket with SSL. This method is designed for testing purposes only. Arguments : ssl bool - If True, wraps the server\u2019s socket with SSL. Defaults to False.","title":"uApp.run"},{"location":"wsgi-server/","text":"wsgi_srv This module serves as an HTTP server using the Waitress WSGI server. It provides command-line options for configuring the server\u2019s host, port, log level, and number of threads. If no additional modules are specified as arguments, default routes are defined for testing purposes, including endpoints that demonstrate handling of positional and keyword arguments, as well as error scenarios. Command-line options: --threads: Set the number of threads to use (default: 2). --log-level: Set the logging level from 1 to 100 (default: 20). --ip: Specify the IP address for the server (default: 127.0.0.1). --port: Specify the port for the server (default: 5000). Example usage: $ python wsgi_py.py --threads 4 --log-level 30 --ip 0.0.0.0 --port 8000","title":"WSGI server"},{"location":"wsgi-server/#wsgi_srv","text":"This module serves as an HTTP server using the Waitress WSGI server. It provides command-line options for configuring the server\u2019s host, port, log level, and number of threads. If no additional modules are specified as arguments, default routes are defined for testing purposes, including endpoints that demonstrate handling of positional and keyword arguments, as well as error scenarios.","title":"wsgi_srv"},{"location":"wsgi-server/#command-line-options","text":"--threads: Set the number of threads to use (default: 2). --log-level: Set the logging level from 1 to 100 (default: 20). --ip: Specify the IP address for the server (default: 127.0.0.1). --port: Specify the port for the server (default: 5000).","title":"Command-line options:"},{"location":"wsgi-server/#example-usage","text":"$ python wsgi_py.py --threads 4 --log-level 30 --ip 0.0.0.0 --port 8000","title":"Example usage:"}]}